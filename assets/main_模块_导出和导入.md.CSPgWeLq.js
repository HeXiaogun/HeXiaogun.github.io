import{_ as l,c as t,o as e,ae as i}from"./chunks/framework.Dh1jimFm.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{"date":"2025-04-26T00:00:00.000Z","tags":["js"]},"headers":[],"relativePath":"main/模块/导出和导入.md","filePath":"main/模块/导出和导入.md","lastUpdated":1746186059000}'),s={name:"main/模块/导出和导入.md"};function r(a,o,n,d,c,_){return e(),t("div",null,o[0]||(o[0]=[i("<ol><li><strong>在声明前导出</strong><ol><li>我们可以通过在声明之前放置 <code>export</code> 来标记任意声明为导出，无论声明的是变量，函数还是类都可以。</li><li>导出 class/function 后没有分号</li></ol></li><li><strong>导出与声明分开</strong></li><li><strong>Import <code>*</code></strong><ol><li>通常，我们把要导入的东西列在花括号 <code>import {...}</code> 中</li><li>但是如果有很多要导入的内容，我们可以使用 <code>import * as &lt;obj&gt;</code> 将所有内容导入为一个对象</li></ol></li><li><strong>Import “as”</strong> 取个别名 <ol><li>也可以使用 <code>as</code> 让导入具有不同的名字。</li><li>import {sayHi as hi, sayBye as bye} from &#39;./say.js&#39;;</li></ol></li><li><strong>Export “as”</strong> 取个别名 <ol><li>export {sayHi as hi, sayBye as bye};</li></ol></li><li><strong>Export default</strong><ul><li>包含库或函数包的模块，像上面的 <code>say.js</code>。</li><li>声明单个实体的模块，例如模块 <code>user.js</code> 仅导出 <code>class User</code>。</li></ul></li><li><strong>“default” 名称</strong><ol><li>在某些情况下，<code>default</code> 关键词被用于引用默认的导出。</li></ol></li><li><strong>我应该使用默认的导出吗？</strong><ol><li>命名的导出是明确的。它们确切地命名了它们要导出的内容，因此我们能从它们获得这些信息，这是一件好事。</li></ol></li><li><strong>重新导出</strong><ol><li>“重新导出（Re-export）”语法 <code>export ... from ...</code> 允许导入内容，并立即将其导出（可能是用的是其他的名字）</li></ol></li><li><strong>重新导出默认导出</strong><ol><li>要重新导出默认导出，我们必须明确写出 <code>export {default as User}</code>，</li></ol></li></ol>",1)]))}const m=l(s,[["render",r]]);export{g as __pageData,m as default};
