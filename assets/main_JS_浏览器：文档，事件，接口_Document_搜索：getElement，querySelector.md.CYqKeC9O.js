import{_ as o,c as l,o as t,ae as c}from"./chunks/framework.Dh1jimFm.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{"date":"2025-04-29T00:00:00.000Z","tags":["js"]},"headers":[],"relativePath":"main/JS/浏览器：文档，事件，接口/Document/搜索：getElement，querySelector.md","filePath":"main/JS/浏览器：文档，事件，接口/Document/搜索：getElement，querySelector.md","lastUpdated":1746068392000}'),d={name:"main/JS/浏览器：文档，事件，接口/Document/搜索：getElement，querySelector.md"};function s(r,e,i,n,a,m){return t(),l("div",null,e[0]||(e[0]=[c('<ol><li><strong>document.getElementById 或者只使用 id</strong><ol><li>如果一个元素有 <code>id</code> 特性（attribute），那我们就可以使用 <code>document.getElementById(id)</code> 方法获取该元素，无论它在哪里</li><li><strong>请不要使用以 id 命名的全局变量来访问元素</strong></li><li><strong><code>id</code> 必须是唯一的</strong></li></ol></li><li><strong>querySelectorAll</strong><ol><li>到目前为止，最通用的方法是 <code>elem.querySelectorAll(css)</code>，它返回 <code>elem</code> 中与给定 CSS 选择器匹配的所有元素。</li><li>CSS 选择器的伪类，例如 <code>:hover</code> 和 <code>:active</code> 也都是被支持的。</li></ol></li><li><strong>querySelector</strong><ol><li><code>elem.querySelector(css)</code> 调用会返回给定 CSS 选择器的第一个元素。</li><li>换句话说，结果与 <code>elem.querySelectorAll(css)[0]</code> 相同，但是后者会查找 <strong>所有</strong> 元素，并从中选取一个，而 <code>elem.querySelector</code> 只会查找一个。因此它在速度上更快，并且写起来更短。</li></ol></li><li><strong>matches</strong><ol><li><a href="https://dom.spec.whatwg.org/#dom-element-matches" target="_blank" rel="noreferrer">elem.matches(css)</a> 不会查找任何内容，它只会检查 <code>elem</code> 是否与给定的 CSS 选择器匹配。它返回 <code>true</code> 或 <code>false</code>。</li><li>当我们遍历元素（例如数组或其他内容）并试图过滤那些我们感兴趣的元素时，这个方法会很有用。</li></ol></li><li><strong>closest</strong><ol><li>元素的祖先（ancestor）是：父级，父级的父级，它的父级等。祖先们一起组成了从元素到顶端的父级链。</li><li><code>elem.closest(css)</code> 方法会查找与 CSS 选择器匹配的最近的祖先。<code>elem</code> 自己也会被搜索。</li><li>换句话说，方法 <code>closest</code> 在元素中得到了提升，并检查每个父级。如果它与选择器匹配，则停止搜索并返回该祖先。</li></ol></li><li><strong>getElementsBy<code>*</code></strong><ul><li><code>elem.getElementsByTagName(tag)</code> 查找具有给定标签的元素，并返回它们的集合。<code>tag</code> 参数也可以是对于“任何标签”的星号 <code>&quot;*&quot;</code>。</li><li><code>elem.getElementsByClassName(className)</code> 返回具有给定CSS类的元素。</li><li><code>document.getElementsByName(name)</code> 返回在文档范围内具有给定 <code>name</code> 特性的元素。很少使用。</li></ul><ol><li>不要忘记字母 <code>&quot;s&quot;</code>！ <ol><li>调用 <code>getElementByTagName</code> 而不是 <code>getElement**s**ByTagName</code>。</li></ol></li><li>它返回的是一个集合，不是一个元素！</li></ol></li><li><strong>实时的集合</strong><ol><li>所有的 <code>&quot;getElementsBy*&quot;</code> 方法都会返回一个 <strong>实时的（live）</strong> 集合。这样的集合始终反映的是文档的当前状态，并且在文档发生更改时会“自动更新”。</li><li><code>querySelectorAll</code> 返回的是一个 <strong>静态的</strong> 集合。就像元素的固定数组。</li></ol></li></ol>',1)]))}const S=o(d,[["render",s]]);export{u as __pageData,S as default};
