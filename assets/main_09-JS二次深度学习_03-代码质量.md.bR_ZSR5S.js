import{_ as s,c as l,o as a,ae as n}from"./chunks/framework.Dgg8-8ov.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{"tags":["js"]},"headers":[],"relativePath":"main/09-JS二次深度学习/03-代码质量.md","filePath":"main/09-JS二次深度学习/03-代码质量.md","lastUpdated":1747318796000}'),t={name:"main/09-JS二次深度学习/03-代码质量.md"};function e(r,i,h,p,o,k){return a(),l("div",null,i[0]||(i[0]=[n(`<h2 id="在浏览器中调试" tabindex="-1">在浏览器中调试 <a class="header-anchor" href="#在浏览器中调试" aria-label="Permalink to &quot;在浏览器中调试&quot;">​</a></h2><ol><li>“资源（Sources）”面板 <ol><li>按住F12打开。</li><li><ol><li><strong>文件导航（File Navigator）</strong> 区域列出了 HTML、JavaScript、CSS 和包括图片在内的其他依附于此页面的文件。Chrome 扩展程序也会显示在这。</li></ol></li><li><strong>代码编辑（Code Editor）</strong> 区域展示源码。</li><li><strong>JavaScript 调试（JavaScript Debugging）</strong> 区域是用于调试的，我们很快就会来探索它。</li></ol></li><li>控制台 <ol><li>可以输入一些命令然后按下 Enter 来执行。</li></ol></li><li>断点（Breakpoints） <ol><li>条件断点，在行号上 <strong>右键单击</strong> 允许你创建一个 <strong>条件</strong> 断点。只有当给定的表达式（你创建条件断点时提供的表达式）为真时才会被触发。</li></ol></li><li>“debugger” 命令</li><li>暂停并查看 <ol><li><strong><code>察看（Watch）</code> —— 显示任意表达式的当前值。</strong></li><li><strong><code>调用栈（Call Stack）</code> —— 显示嵌套的调用链。</strong></li><li><strong><code>作用域（Scope）</code> —— 显示当前的变量。</strong><ol><li><code>Local</code> 显示当前函数中的变量，你还可以在源代码中看到它们的值高亮显示了出来</li><li><code>Global</code> 显示全局变量（不在任何函数中）。</li></ol></li></ol></li><li>跟踪执行 <ol><li>▶—— “恢复（Resume）”：继续执行，快捷键 F8。放行那个符号</li><li>-&gt;· —— “下一步（Step）”：运行下一条（即当前行）指令，快捷键 F9。</li><li>↻  —— “跨步（Step over）”：运行下一条（即当前行）指令，但 <strong>不会进入到一个函数中</strong>，快捷键 F10。</li><li>↓—— “步入（Step into）”，快捷键 F11。</li><li>↑—— “步出（Step out）”：继续执行到当前函数的末尾，快捷键 Shift+F11。</li><li>—— 启用/禁用所有的断点。</li><li>—— 启用/禁用出现错误时自动暂停脚本执行。</li><li>在代码中的某一行上右键，在显示的关联菜单（context menu）中点击一个非常有用的名为 “Continue to here” 的选项。</li></ol></li><li>日志记录 <ol><li>console.log()</li></ol></li></ol><h2 id="代码风格" tabindex="-1">代码风格 <a class="header-anchor" href="#代码风格" aria-label="Permalink to &quot;代码风格&quot;">​</a></h2><p>代码必须尽可能的清晰和易读。</p><ol><li>语法 <ol><li>没有什么规则是“必须”的</li></ol></li><li>花括号 <ol><li>花括号以 “Egyptian” 风格（译注：“egyptian” 风格又称 K&amp;R 风格</li><li>比如if的执行代码体只有一行的时候，就不需要花括号</li><li>单独拆分出的一行 要带花括号</li></ol></li><li>行的长度 <ol><li>没有人喜欢读一长串代码，最好将代码分割一下，增加可读性和美观</li></ol></li><li>缩进 <ol><li>水平方向上的缩进：2 或 4 个空格。</li><li>垂直方向上的缩进：用于将代码拆分成逻辑块的空行。</li></ol></li><li>分号 <ol><li>每一个语句后面都应该有一个分号。即使它可以被跳过。</li></ol></li><li>嵌套的层级 <ol><li>尽量避免代码嵌套层级过深。</li></ol></li><li>函数位置 <ol><li>先写调用代码，再写函数</li></ol></li><li>风格指南 <ul><li><a href="https://google.github.io/styleguide/jsguide.html" target="_blank" rel="noreferrer">Google JavaScript 风格指南</a></li><li><a href="https://github.com/airbnb/javascript" target="_blank" rel="noreferrer">Airbnb JavaScript 风格指南</a></li><li><a href="https://github.com/rwaldron/idiomatic.js" target="_blank" rel="noreferrer">Idiomatic.JS</a></li><li><a href="https://standardjs.com/" target="_blank" rel="noreferrer">StandardJS</a></li></ul></li><li>自动检查器 <ul><li><a href="https://www.jslint.com/" target="_blank" rel="noreferrer">JSLint</a> —— 第一批检查器之一。</li><li><a href="https://www.jshint.com/" target="_blank" rel="noreferrer">JSHint</a> —— 比 JSLint 多了更多设置。</li><li><a href="https://eslint.org/" target="_blank" rel="noreferrer">ESLint</a> —— 应该是最新的一个。 <ol><li>使用EsLint</li><li>安装 <a href="https://nodejs.org/" target="_blank" rel="noreferrer">Node.JS</a>。</li><li>使用 <code>npm install -g eslint</code> 命令（npm 是一个 JavaScript 包安装工具）安装 ESLint。</li><li>在 JavaScript 项目的根目录（包含该项目的所有文件的那个文件夹）创建一个名为 <code>.eslintrc</code> 的配置文件</li><li>在集成了 ESLint 的编辑器中安装/启用插件。大多数编辑器都有这个选项。</li></ol></li></ul></li></ol><h2 id="注释" tabindex="-1">注释 <a class="header-anchor" href="#注释" aria-label="Permalink to &quot;注释&quot;">​</a></h2><p>注释可以是以 <code>//</code> 开始的单行注释，也可以是 <code>/* ... */</code> 结构的多行注释，vscode块级注释  Alt + Shift + A</p><ol><li>配方：分解函数 <ol><li>用一个函数来代替一个代码片段是更好的</li></ol></li><li>配方：创建函数</li><li>好的注释 <ol><li>描述架构</li><li>记录函数的参数和用法</li></ol></li><li>避免注释 <ol><li><ul><li>描述“代码如何工作”和“代码做了什么”。</li></ul></li><li><ul><li>避免在代码已经足够简单或代码有很好的自描述性而不需要注释的情况下，还写些没必要的注释。</li></ul></li></ol></li></ol><h2 id="忍者代码" tabindex="-1">忍者代码 <a class="header-anchor" href="#忍者代码" aria-label="Permalink to &quot;忍者代码&quot;">​</a></h2><p>前辈写代码的技巧 <a href="https://zh.javascript.info/ninja-code" target="_blank" rel="noreferrer">https://zh.javascript.info/ninja-code</a></p><h2 id="使用-mocha-进行自动化测试" tabindex="-1">使用 Mocha 进行自动化测试 <a class="header-anchor" href="#使用-mocha-进行自动化测试" aria-label="Permalink to &quot;使用 Mocha 进行自动化测试&quot;">​</a></h2><p><strong>当通过手动重新运行来测试代码时，很容易漏掉一些东西。</strong><strong>自动化测试意味着测试是独立于代码的。它们以各种方式运行我们的函数，并将结果与预期结果进行比较。</strong></p><ol><li>行为驱动开发（BDD） <ol><li>BDD 包含了三部分内容：测试、文档和示例。</li></ol></li><li>规范</li></ol><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	describe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;pow&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	  it</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;raises to n-th power&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	    assert.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">equal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	});</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> describe：我们正在描述的功能是什么。在我们的例子中我们正在描述函数 </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`pow\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">。用于组织“工人（workers）” —— </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`it\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 代码块。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> it：里面的描述部分，我们以一种 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">易于理解</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 的方式描述特定的用例，第二个参数是用于对其进行测试的函数。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> assert：</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`it\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 块中的代码，如果实现是正确的，它应该在执行的时候不产生任何错误。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	4.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ol start="3"><li>开发流程 <ol><li>编写初始规范，测试最基本的功能。</li><li>创建一个最初始的实现。</li><li>检查它是否工作，我们运行测试框架 <a href="http://mochajs.org/" target="_blank" rel="noreferrer">Mocha</a>（很快会有更多细节）来运行测试。当功能未完成时，将显示错误。我们持续修正直到一切都能工作。</li><li>现在我们有一个带有测试的能工作的初步实现。</li><li>我们增加更多的用例到规范中，或许目前的程序实现还不支持。无法通过测试。</li><li>回到第 3 步，更新程序直到测试不会抛出错误。</li><li>重复第 3 步到第 6 步，直到功能完善。</li></ol></li><li>行为规范 <ol><li><ul><li><a href="http://mochajs.org/" target="_blank" rel="noreferrer">Mocha</a> —— 核心框架：提供了包括通用型测试函数 <code>describe</code> 和 <code>it</code>，以及用于运行测试的主函数。</li></ul></li><li><ul><li><a href="http://chaijs.com/" target="_blank" rel="noreferrer">Chai</a> —— 提供很多断言（assertion）支持的库。它提供了很多不同的断言，现在我们只需要用 <code>assert.equal</code>。</li></ul></li><li><ul><li><a href="http://sinonjs.org/" target="_blank" rel="noreferrer">Sinon</a> —— 用于监视函数、模拟内建函数和其他函数的库，我们在后面才会用到它。</li></ul></li></ol></li><li>初始实现</li><li>改进规范</li><li>一个测试检查一个东西。 <ol><li>有两个相互独立的检查 —— 最好将它拆分成两个更简单的检查。</li></ol></li></ol><h2 id="polyfill-和转译器" tabindex="-1">Polyfill 和转译器 <a class="header-anchor" href="#polyfill-和转译器" aria-label="Permalink to &quot;Polyfill 和转译器&quot;">​</a></h2><ol><li>转译器（Transpilers） <ol><li>转译器 是一种可以将源码转译成另一种源码的特殊的软件。</li><li><code>height ?? 100</code> 重写为 <code>(height !== undefined &amp;&amp; height !== null) ? height : 100</code>。</li></ol></li><li>垫片（Polyfills） <ol><li>新的语言特性可能不仅包括语法结构和运算符，还可能包括内建函数。</li></ol></li></ol><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Math.trunc) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果没有这个函数</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	  // 实现它</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trunc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	    // Math.ceil 和 Math.floor 甚至存在于上古年代的 JavaScript 引擎中</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	    // 在本教程的后续章节中会讲到它们</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ceil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(number) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">floor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(number);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol start="3"><li>搭建一个基于 <a href="https://webpack.js.org/" target="_blank" rel="noreferrer">webpack</a> 和 <a href="https://github.com/babel/babel-loader" target="_blank" rel="noreferrer">babel-loader</a> 插件的代码构建系统。 <ol><li><a href="https://compat-table.github.io/compat-table/es6/" target="_blank" rel="noreferrer">https://compat-table.github.io/compat-table/es6/</a> —— 对于原生 JavaScript。</li><li><a href="https://caniuse.com/" target="_blank" rel="noreferrer">https://caniuse.com/</a> —— 对于浏览器相关的函数。</li></ol></li></ol>`,19)]))}const E=s(t,[["render",e]]);export{c as __pageData,E as default};
