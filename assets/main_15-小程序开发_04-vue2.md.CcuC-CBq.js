import{_ as e,c as o,o as a,ae as i,j as s,t}from"./chunks/framework.Dgg8-8ov.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"main/15-小程序开发/04-vue2.md","filePath":"main/15-小程序开发/04-vue2.md","lastUpdated":1750931891000}'),n={name:"main/15-小程序开发/04-vue2.md"},r={start:"2"};function d(c,l,p,h,_,v){return a(),o("div",null,[l[2]||(l[2]=i('<h2 id="模版语法" tabindex="-1">模版语法 <a class="header-anchor" href="#模版语法" aria-label="Permalink to &quot;模版语法&quot;">​</a></h2><h3 id="插值" tabindex="-1">插值 <a class="header-anchor" href="#插值" aria-label="Permalink to &quot;插值&quot;">​</a></h3><ol><li>数据绑定最常见的形式就是文本插值，{</li><li>v-once,一次性插值</li><li>v-html，输出真的html</li><li><strong>v-bind指令</strong><ol><li>动态地绑定一个或多个属性，或一个组件 <code>prop</code> 到表达式。</li><li>可以缩写为：</li><li>在绑定 <code>prop</code> 时，<code>prop</code> 必须在子组件中声明。</li><li>可以用修饰符指定不同的绑定类型。</li></ol></li><li>JS表达式 <ol><li>三元</li><li>算术</li><li>复杂的函数运算</li></ol></li></ol><h3 id="指令" tabindex="-1">指令 <a class="header-anchor" href="#指令" aria-label="Permalink to &quot;指令&quot;">​</a></h3>',4)),s("ol",null,[l[1]||(l[1]=i("<li>带有<code>v-</code>前缀的特殊属性</li><li><strong>v-bind</strong></li><li><strong>v-on</strong><ol><li>它用于监听 DOM 事件</li><li>可以缩写为<code>@</code>，<code>v-on:click</code> -&gt; <code>@click</code></li></ol></li><li><strong>v-once</strong><ol><li>只渲染元素和组件一次。</li><li>添加了 <code>v-once</code> 能保证节点只渲染一次，但是并不一定能优化渲染性能，反而可能会拖慢客户端复用节点时的比对效率。</li></ol></li><li><strong>v-html</strong><ol><li><strong>内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译。</strong></li><li>App端和H5端支持 <code>v-html</code> ，微信小程序会被转为 <code>rich-text</code></li></ol></li>",5)),s("li",null,[l[0]||(l[0]=i(`<strong>data属性</strong><ol><li>必须声明为返回一个初始数据对象的函数</li></ol><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	//正确用法，使用函数返回对象</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			title: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div>`,3)),s("ol",r,[s("li",null,"两种绑定方式："+t()+"，属性区域通过:属性名称",1)])])]),l[3]||(l[3]=i('<h3 id="class-与-style-绑定" tabindex="-1">Class 与 Style 绑定 <a class="header-anchor" href="#class-与-style-绑定" aria-label="Permalink to &quot;Class 与 Style 绑定&quot;">​</a></h3><ol><li><strong>对象语法</strong><ol><li>可以传给 v-bind:class 一个对象，实现动态地切换 class。</li></ol></li><li><strong>数组语法</strong><ol><li>可以把一个数组传给 v-bind:class，以应用一个 class 列表。</li><li><code>:class=&quot;[activeClass,errorClass]&quot;</code></li><li><strong>以:style=&quot;&quot;这样的方式设置px像素值，其值为实际像素，不会被编译器转换。</strong></li><li>小程序端不支持 <code>classObject</code> 和 <code>styleObject</code> 语法。</li></ol></li></ol><h3 id="条件渲染" tabindex="-1">条件渲染 <a class="header-anchor" href="#条件渲染" aria-label="Permalink to &quot;条件渲染&quot;">​</a></h3><ol><li><strong>v-if和v-else</strong><ol><li><code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 <code>truthy</code> 值的时候被渲染。 使用 <code>v-else</code> 指令来表示 v-if 的“else 块”。</li></ol></li><li><strong>条件渲染分组</strong><ol><li>因为 <code>v-if</code> 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 标签元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含该 元素。</li></ol></li><li><strong>v-show</strong><ol><li>带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 <code>CSS</code> 属性的 <code>display</code> 。</li></ol></li><li><strong>v-if 和 v-show 区别</strong><ol><li><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</li><li><code>v-show</code>不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换，来控制元素的显示和隐藏。</li><li>如果需要非常频繁地切换，则使用 v-show 较好。</li><li>如果在运行时条件很少改变，则使用 v-if 较好。</li><li><ul><li>不推荐同时使用 <code>v-if</code> 和 <code>v-for</code>。</li></ul></li><li><ul><li>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级。</li></ul></li></ol></li></ol><h3 id="列表渲染" tabindex="-1">列表渲染 <a class="header-anchor" href="#列表渲染" aria-label="Permalink to &quot;列表渲染&quot;">​</a></h3>',5))])}const k=e(n,[["render",d]]);export{g as __pageData,k as default};
