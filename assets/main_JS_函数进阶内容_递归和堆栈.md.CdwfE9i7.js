import{_ as i,c as a,o as n,ae as t}from"./chunks/framework.Dh1jimFm.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{"date":"2025-04-25T00:00:00.000Z","tags":["js"]},"headers":[],"relativePath":"main/JS/函数进阶内容/递归和堆栈.md","filePath":"main/JS/函数进阶内容/递归和堆栈.md","lastUpdated":1746068392000}'),l={name:"main/JS/函数进阶内容/递归和堆栈.md"};function e(p,s,r,h,k,o){return n(),a("div",null,s[0]||(s[0]=[t(`<ol><li><strong>递归</strong><ol><li><p>函数会调用 <strong>自身</strong>。这就是所谓的 <strong>递归</strong>。</p></li><li><p><strong>两种思考方式</strong></p><ol><li>迭代思路：使用 <code>for</code> 循环</li><li>递归思路：简化任务，调用自身</li></ol></li></ol></li></ol><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><pre><code>	最大的嵌套调用次数（包括首次）被称为 递归深度。
1. 执行上下文和堆栈
	1. 有关正在运行的函数的执行过程的相关信息被存储在其 **执行上下文** 中。
	2. [执行上下文](https://tc39.github.io/ecma262/#sec-execution-contexts) 是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置，当前的变量，\`this\` 的值（此处我们不使用它），以及其它的一些内部细节。
</code></pre><ol start="3"><li><strong>出口</strong><ol><li><strong>任何递归都可以用循环来重写。通常循环变体更有效。</strong></li></ol></li><li><strong>递归遍历</strong></li><li><strong>递归结构</strong></li><li><strong>链表</strong><ol><li>value</li><li><ul><li><code>next</code> 属性引用下一个 <strong>链表元素</strong> 或者代表末尾的 <code>null</code>。</li></ul></li></ol></li></ol>`,4)]))}const c=i(l,[["render",e]]);export{g as __pageData,c as default};
