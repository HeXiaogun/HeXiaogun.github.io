import{_ as i,c as l,o as a,ae as n}from"./chunks/framework.Dh1jimFm.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{"date":"2025-04-23T00:00:00.000Z","tags":["js"]},"headers":[],"relativePath":"main/Object（对象）：基础知识/垃圾回收.md","filePath":"main/Object（对象）：基础知识/垃圾回收.md","lastUpdated":1746186059000}'),e={name:"main/Object（对象）：基础知识/垃圾回收.md"};function p(t,s,r,h,k,E){return a(),l("div",null,s[0]||(s[0]=[n(`<p>我们创建的原始值、对象、函数……这一切都会占用内存。</p><ol><li>可达性（Reachability） <ol><li>“可达”值是那些以某种方式可访问或可用的值。它们被存储在内存中</li><li>固有的可达值的基本集合，这些值明显不能被释放。这些值被称作 <strong>根（roots）</strong>。 <ol><li><ul><li>当前执行的函数，它的局部变量和参数。</li></ul></li><li><ul><li>当前嵌套调用链上的其他函数、它们的局部变量和参数。</li></ul></li><li>全局变量</li><li><ul><li>（还有一些其他的，内部实现）</li></ul></li></ol></li><li>如果一个值可以从根通过引用或者引用链进行访问，则认为该值是可达的。，如果全局变量中有一个对象，并且该对象有一个属性引用了另一个对象，则 <strong>该</strong> 对象被认为是可达的。而且它引用的内容也是可达的。</li></ol></li><li>例子 <ol><li>如果 全局变量<code>user</code> 的值（初始值：a）被重写了，这个引用就没了。那之前全局变量user初始化的值a就变得不可达了，引用没了，就不能访问到a了，</li><li>垃圾回收器会认为它是垃圾数据并进行回收，然后释放内存。</li></ol></li><li>两个引用 <ol><li>如果全局变量user引用复制给了admin，重写了user里面属性的值，但是之前的属性值可以通过admin访问到。如果我们又重写了 <code>admin</code>，对象就会被删除。</li></ol></li><li>相互关联的对象</li></ol><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> marry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">man</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">woman</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  woman.husband </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> man;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  man.wife </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> woman;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	    father: man,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	    mother: woman</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> family </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> marry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;John&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Ann&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	现在所有对象都可达</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//移除两个引用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> family.father;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> family.mother.husband;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	John现在不可达</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><ol start="5"><li>无法到达的岛屿 <ol><li>几个对象相互引用，但外部没有对其任意对象的引用，这些对象也可能是不可达的，并被从内存中删除。</li></ol></li><li>内部算法 <ol><li>垃圾回收的基本算法被称为 “mark-and-sweep”。</li><li>垃圾回收步骤： <ol><li><ul><li>垃圾收集器找到所有的根，并“标记”（记住）它们。</li></ul></li><li><ul><li>然后它遍历并“标记”来自它们的所有引用。</li></ul></li><li><ul><li>然后它遍历标记的对象并标记 <strong>它们的</strong> 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。</li></ul></li><li><ul><li>……如此操作，直到所有可达的（从根部）引用都被访问到。</li></ul></li><li><ul><li>没有被标记的对象都会被删除。</li></ul></li></ol></li><li><strong>分代收集（Generational collection）</strong><ol><li>新对象（工作完就是去意义的对象）内存就会把它们及时清理，长期存在的对象检查的频率就会变小</li></ol></li><li><strong>增量收集（Incremental collection）</strong><ol><li>引擎将现有的整个对象集拆分为多个部分，这样会带来许多微小的延迟而不是一个大的延迟。</li></ol></li><li><strong>闲时收集（Idle-time collection）</strong><ol><li>垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。</li></ol></li></ol></li><li>总结 <ol><li><ul><li>垃圾回收是自动完成的，我们不能强制执行或是阻止执行。</li></ul></li><li><ul><li>当对象是可达状态时，它一定是存在于内存中的。</li></ul></li><li><ul><li>被引用与可访问（从一个根）不同：一组相互连接的对象可能整体都不可达。</li></ul></li><li><a href="http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection" target="_blank" rel="noreferrer">V8 之旅：垃圾回收</a>。</li></ol></li></ol>`,4)]))}const d=i(e,[["render",p]]);export{c as __pageData,d as default};
