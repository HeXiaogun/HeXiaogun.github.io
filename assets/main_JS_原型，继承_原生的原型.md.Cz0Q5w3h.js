import{_ as t,c as e,o as l,ae as i}from"./chunks/framework.Dh1jimFm.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{"date":"2025-04-25T00:00:00.000Z","tags":["js"]},"headers":[],"relativePath":"main/JS/原型，继承/原生的原型.md","filePath":"main/JS/原型，继承/原生的原型.md","lastUpdated":1746068392000}'),c={name:"main/JS/原型，继承/原生的原型.md"};function r(n,o,a,d,s,p){return l(),e("div",null,o[0]||(o[0]=[i("<p>&quot;prototype&quot; 属性在 JavaScript 自身的核心部分中被广泛地应用。所有的内建构造函数都用到了它。</p><ol><li><strong>Object.prototype</strong><ol><li>let obj = {}; alert( obj ); // &quot;[object Object]&quot; ?</li><li><code>obj = {}</code> 和 <code>obj = new Object()</code> 是一个意思，其中 <code>Object</code> 就是一个内建的对象构造函数，其自身的 <code>prototype</code> 指向一个带有 <code>toString</code> 和其他方法的一个巨大的对象。</li></ol></li><li><strong>其他内建原型</strong><ol><li>其他内建对象，像 <code>Array</code>、<code>Date</code>、<code>Function</code> 及其他，都在 prototype 上挂载了方法。</li></ol></li><li><strong>基本数据类型</strong><ol><li>最复杂的事情发生在字符串、数字和布尔值上。</li><li>值 <code>null</code> 和 <code>undefined</code> 没有对象包装器</li></ol></li><li><strong>更改原生原型</strong><ol><li>重要： <ol><li>原型是全局的，所以很容易造成冲突。如果有两个库都添加了 <code>String.prototype.show</code> 方法，那么其中的一个方法将被另一个覆盖。</li><li><strong>在现代编程中，只有一种情况下允许修改原生原型。那就是 polyfilling。</strong></li><li>Polyfilling 是一个术语，表示某个方法在 JavaScript 规范中已存在，但是特定的 JavaScript 引擎尚不支持该方法，那么我们可以通过手动实现它，并用以填充内建原型。</li></ol></li></ol></li><li><strong>从原型中借用</strong><ol><li>那是指我们从一个对象获取一个方法，并将其复制到另一个对象。一些原生原型的方法通常会被借用。</li><li></li></ol></li></ol>",2)]))}const S=t(c,[["render",r]]);export{g as __pageData,S as default};
