import{_ as o,c as t,o as c,ae as r}from"./chunks/framework.Dh1jimFm.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{"date":"2025-04-28T00:00:00.000Z","tags":["js"]},"headers":[],"relativePath":"main/JS/杂项/Reference Type.md","filePath":"main/JS/杂项/Reference Type.md","lastUpdated":1746068392000}'),i={name:"main/JS/杂项/Reference Type.md"};function l(a,e,n,d,s,p){return c(),t("div",null,e[0]||(e[0]=[r('<p>一个动态执行的方法调用可能会丢失 <code>this</code></p><ol><li><strong>Reference type 解读</strong><ol><li>仔细看的话，我们可能注意到 <code>obj.method()</code> 语句中的两个操作： <ol><li><ol><li>首先，点 <code>&#39;.&#39;</code> 取了属性 <code>obj.method</code> 的值。</li></ol></li><li><ol><li>接着 <code>()</code> 执行了它。</li></ol></li><li><strong>为确保 <code>user.hi()</code> 调用正常运行，JavaScript 玩了个小把戏 —— 点 <code>&#39;.&#39;</code> 返回的不是一个函数，而是一个特殊的 <a href="https://tc39.github.io/ecma262/#sec-reference-specification-type" target="_blank" rel="noreferrer">Reference Type</a> 的值。</strong></li><li></li></ol></li></ol></li></ol>',2)]))}const m=o(i,[["render",l]]);export{f as __pageData,m as default};
