import{_ as o,c,o as d,ae as l}from"./chunks/framework.Dh1jimFm.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{"date":"2025-04-24T00:00:00.000Z","tags":["js"]},"headers":[],"relativePath":"main/数据类型/数字类型.md","filePath":"main/数据类型/数字类型.md","lastUpdated":1746186059000}'),i={name:"main/数据类型/数字类型.md"};function t(a,e,r,n,s,p){return d(),c("div",null,e[0]||(e[0]=[l('<ol><li>number类型：常规数字以 64 位的格式 <a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noreferrer">IEEE-754</a> 存储，也被称为“双精度浮点数”。</li><li>BigInt 用于表示任意长度的整数</li><li>编写数字的更多方法 <ol><li><code>let</code> billion <code>=</code> <code>1000000000``;</code></li><li><code>let</code> billion <code>=</code> <code>1_000_000_000``;</code> 可以用下划线这种方式写</li><li><code>let</code> billion <code>=</code> <code>1e9``;</code> <code>// 10 亿，字面意思：数字 1 后面跟 9 个 0</code></li><li><code>let</code> mcs <code>=</code> <code>1e-6``;</code> <code>// 1 的左边有 6 个 0</code> 0.000001</li></ol></li><li>十六进制，二进制和八进制数字 <ol><li>0xff 和oxFF 一样</li><li>0b 二进制，0o八进制</li></ol></li><li>toString(base) <ol><li>方法 <code>num.toString(base)</code> 返回在给定 <code>base</code> 进制数字系统中 <code>num</code> 的字符串表示形式。</li><li><code>base</code> 的范围可以从 <code>2</code> 到 <code>36</code>，默认是10</li></ol></li><li>舍入 <ol><li>Math.floor：向下舍入：<code>3.1</code> 变成 <code>3</code>，<code>-1.1</code> 变成 <code>-2</code>。</li><li>Math.ceil： 向上舍入：<code>3.1</code> 变成 <code>4</code>，<code>-1.1</code> 变成 <code>-1</code>。</li><li>Math.round：向最近的整数舍入：<code>3.1</code> 变成 <code>3</code>，<code>3.6</code> 变成 <code>4</code>，中间值 <code>3.5</code> 变成 <code>4</code>。</li><li><code>Math.trunc</code>（IE 浏览器不支持这个方法）：移除小数点后的所有内容而没有舍入：<code>3.1</code> 变成 <code>3</code>，<code>-1.1</code> 变成 <code>-1</code>。</li><li>函数 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed" target="_blank" rel="noreferrer">toFixed(n)</a> 将数字舍入到小数点后 <code>n</code> 位，并以字符串形式返回结果，结尾不够会添0</li><li>不精确的计算 <ol><li>如果一个数字真的很大，则可能会溢出 64 位存储，变成一个特殊的数值 <code>Infinity</code></li><li>0.1+0.2=0.30000000000000004 <ol><li>解决方法：</li><li><code>let</code> sum <code>=</code> <code>0.1</code> <code>+</code> <code>0.2``;</code></li><li><code>alert``(</code> sum<code>.``toFixed``(``2``)</code> <code>)``;</code> <code>// &quot;0.30&quot;</code></li></ol></li><li>自我增加的数字：<code>alert``(</code> <code>9999999999999999</code> <code>)``;</code> <code>// 显示 10000000000000000</code> 问题出现的原因：精度损失</li><li>两个零 <ol><li>存在两个零：<code>0</code> 和 <code>-0</code>。</li></ol></li></ol></li></ol></li><li>测试：isFinite 和 isNaN 1. - <code>Infinity</code>（和 <code>-Infinity</code>）是一个特殊的数值，比任何数值都大（小）。 2. - <code>NaN</code> 代表一个 error。 3. <code>isNaN(value)</code> 将其参数转换为数字，然后测试它是否为 <code>NaN</code> 4. <code>isFinite(value)</code> 将其参数转换为数字，如果是常规数字而不是 <code>NaN/Infinity/-Infinity</code>，则返回 <code>true</code> 5. 与 Object.is 进行比较 1. 有一个特殊的内建方法 <code>Object.is</code>，它类似于 <code>===</code> 一样对值进行比较，但它对于两种边缘情况更可靠 2. 它适用于 NaN：Object.is(NaN, NaN) === true，这是件好事。 3. 值 <code>0</code> 和 <code>-0</code> 是不同的：<code>Object.is(0, -0) === false</code>，从技术上讲这是对的，因为在内部，数字的符号位可能会不同，即使其他所有位均为零。 4. 在所有其他情况下，<code>Object.is(a, b)</code> 与 <code>a === b</code> 相同。</li><li>parseInt 和 parseFloat 1. 使用加号 <code>+</code> 或 <code>Number()</code> 的数字转换是严格的。如果一个值不完全是一个数字，就会失败 2. alert( parseInt(&#39;100px&#39;) ); // 100 3. alert( parseFloat(&#39;12.5em&#39;) ); // 12.5 4. alert( parseInt(&#39;12.3&#39;) ); // 12，只有整数部分被返回了 5. alert( parseFloat(&#39;12.3.4&#39;) ); // 12.3，在第二个点出停止了读取 6. alert( parseInt(&#39;a123&#39;) ); // NaN，第一个符号停止了读取 7. parseInt(str, radix) 的第二个参数 1. alert( parseInt(&#39;0xff&#39;, 16) ); // 255 2. alert( parseInt(&#39;ff&#39;, 16) ); // 255，没有 0x 仍然有效 3. alert( parseInt(&#39;2n9c&#39;, 36) ); // 123456</li><li>其他数学函数 1. Math.random() ：返回一个从 0 到 1 的随机数（不包括 1）。 2. Math.max(a, b, c...) 和 Math.min(a, b, c...)：从任意数量的参数中返回最大值和最小值。 3. Math.pow(n, power)：返回 <code>n</code> 的给定（power）次幂。</li></ol>',1)]))}const b=o(i,[["render",t]]);export{f as __pageData,b as default};
