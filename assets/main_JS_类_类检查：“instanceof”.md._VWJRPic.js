import{_ as e,c,o as t,ae as d}from"./chunks/framework.Dh1jimFm.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{"date":"2025-04-25T00:00:00.000Z","tags":["js"]},"headers":[],"relativePath":"main/JS/类/类检查：“instanceof”.md","filePath":"main/JS/类/类检查：“instanceof”.md","lastUpdated":1746068392000}'),n={name:"main/JS/类/类检查：“instanceof”.md"};function l(s,o,a,i,r,_){return t(),c("div",null,o[0]||(o[0]=[d("<p><code>instanceof</code> 操作符用于检查一个对象是否属于某个特定的 class。同时，它还考虑了继承。 在许多情况下，可能都需要进行此类检查。例如，它可以被用来构建一个 <strong>多态性（polymorphic）</strong> 的函数，该函数根据参数的类型对参数进行不同的处理。</p><ol><li><strong>instanceof 操作符</strong><ol><li>obj <code>instanceof</code> <code>Class</code></li><li>如果 <code>obj</code> 隶属于 <code>Class</code> 类（或 <code>Class</code> 类的衍生类），则返回 <code>true</code>。</li><li>如果这儿有静态方法 <code>Symbol.hasInstance</code>，那就直接调用这个方法</li><li>大多数 class 没有 <code>Symbol.hasInstance</code>。在这种情况下，标准的逻辑是：使用 <code>obj instanceOf Class</code> 检查 <code>Class.prototype</code> 是否等于 <code>obj</code> 的原型链中的原型之一。</li></ol></li><li><strong>福利：使用 Object.prototype.toString 方法来揭示类型</strong><ol><li>大家都知道，一个普通对象被转化为字符串时为 <code>[object Object]</code> - 对于 number 类型，结果是 <code>[object Number]</code> - 对于 boolean 类型，结果是 <code>[object Boolean]</code> - 对于 <code>null</code>：<code>[object Null]</code> - 对于 <code>undefined</code>：<code>[object Undefined]</code> - 对于数组：<code>[object Array]</code> - ……等（可自定义）</li></ol></li><li><strong>Symbol.toStringTag</strong><ol><li>可以使用特殊的对象属性 <code>Symbol.toStringTag</code> 自定义对象的 <code>toString</code> 方法的行为。</li></ol></li></ol>",2)]))}const m=e(n,[["render",l]]);export{b as __pageData,m as default};
