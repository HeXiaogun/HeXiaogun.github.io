import{_ as o,c as r,o as s,ae as n}from"./chunks/framework.DvccZNqS.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"main/面试题/CSS相关.md","filePath":"main/面试题/CSS相关.md","lastUpdated":1748354013000}'),e={name:"main/面试题/CSS相关.md"};function i(g,t,l,a,d,p){return s(),r("div",null,t[0]||(t[0]=[n('<ol><li><p><strong>CSS盒模型，在不同浏览器的差异</strong><strong>css 标准盒子模型</strong> css盒子模型 又称为框模型（Box Model），包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。</p><p>内层是content依次是padding border margin。通常我们设置背景时就是内容、内边距、边框这三部分，如果border设置颜色的时候会显示boder颜色当boder颜色是透明时会显示background-color的颜色。而该元素的子元素的是从content开始的。而外边距是透明的，不会遮挡其他元素。</p><p>元素框的总宽度=width+padding-left+padding-right+border-left+border-right+margin-left+margin-right; 元素框的总高度=height+padding-top+padding-bottom+border-top+border-bottom+margin-top+margin-bottom;</p><p><strong>IE盒子模型</strong> 图中的内层是content依次是content padding border。通常我们设置背景时就是内容、内边距、边框这三部分。而外边距是透明的，不会遮挡其他元素。</p><p>元素框的总宽度=width（padding-left+padding-right+border-left+border-right)；   元素框的总高度=height（padding-top+padding-bottom+border-top+border-bottom）; <strong>两个模型宽度和高度的计算（是不一样的）</strong> w3c中的盒子模型的宽:包括margin+border+padding+width; width:margin<em>2+border</em>2+padding<em>2+width; height:margin</em>2+border<em>2+padding</em>2+height;   iE中的盒子模型的width:包括border+padding+width; 上面的两个宽度相加的属性是一样的。 因此我们应该选择标准盒子模型，在网页的顶部加上 DOCTYPE 声明。</p></li><li><p><strong>CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用at规则</strong><strong>css选择器种类有：</strong> 通用选择器：* id选择器：#header{} class选择器：.header{} 元素选择器：div{} 子选择器：ul &gt; li{} 后代选择器：div p{} 伪类选择器：:hover、::selection、.action、:first-child、:last-child、:first-of-type、:last-of-type、:nth-of-type(n)、:nth-of-last-type(n)等,例如a:hover{} 伪元素选择器:  :after、:before等,例如：li:after 属性选择器: input[type=&quot;text&quot;] 组合选择器：E,F/E F（后代选择器）/E&gt;F（子元素选择器）/E+F（直接相邻元素选择器----匹配之后的相邻同级元素）/E~F（普通相邻元素选择器----匹配之后的同级元素） 层次选择器：p~ul 选择前面有p元素的每个ul元素 <strong>css选择器优先级：</strong></p><ul><li>选择器优先级由高到低分别为：<br> !important &gt; 作为style属性写在元素标签上的内联样式 &gt;id选择器&gt;类选择器&gt;伪类选择器&gt;属性选择器&gt;标签选择器&gt; 通配符选择器（* 应少用）&gt;浏览器自定义；</li></ul></li></ol><ul><li><p>当比较多个相同级别的CSS选择器优先级时，它们定义的位置将决定一切。下面从位置上将CSS优先级由高到低分为六级：</p><ol><li>位于标签里的中所定义的CSS拥有最高级的优先权。</li><li>第二级的优先属性由位于 标签中的 @import 引入样式表所定义。</li><li>第三级的优先属性由标签所引入的样式表定义。</li><li>第四级的优先属性由标签所引入的样式表内的 @import 导入样式表定义。</li><li>第五级优先的样式有用户设定。</li><li>最低级的优先权由浏览器默认。</li></ol><p><strong>使用场景</strong>：</p><ul><li>选择器优先级由高到低分别为：<br> !important &gt; 作为style属性写在元素标签上的内联样式 &gt;id选择器&gt;类选择器&gt;伪类选择器&gt;属性选择器&gt;标签选择器&gt; 通配符选择器（* 应少用）&gt;浏览器自定义；</li><li>当比较多个相同级别的CSS选择器优先级时，它们定义的位置将决定一切。下面从位置上将CSS优先级由高到低分为六级： <ol><li>位于标签里的中所定义的CSS拥有最高级的优先权。</li><li>第二级的优先属性由位于 标签中的 @import 引入样式表所定义。</li><li>第三级的优先属性由标签所引入的样式表定义。</li><li>第四级的优先属性由标签所引入的样式表内的 @import 导入样式表定义。</li><li>第五级优先的样式有用户设定。 6、最低级的优先权由浏览器默认。</li></ol></li></ul></li></ul><ol start="2"><li><p><strong>CSS哪些属性可以继承？</strong> css继承特性主要是指文本方面的继承(比如字体、颜色、字体大小等)，盒模型相关的属性基本没有继承特性。 <strong>不可继承的</strong>：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、top、bottom、left、right、z-index、float、clear、 table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。 <strong>所有元素可继承的</strong>：visibility和cursor <strong>终极块级元素可继承的</strong>：text-indent和text-align <strong>内联元素可继承的</strong>：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction <strong>列表元素可继承的</strong>：list-style、list-style-type、list-style-position、list-style-image</p></li><li><p><strong>CSS伪类和伪元素有哪些，它们的区别和实际应用</strong><strong>伪类的例子</strong>： :hover，:active，:first-child，:visited等 <strong>伪元素</strong>：:first-line，:first-letter，:after，:before等 **伪类和伪元素的根本区别在于：<strong>它们是否创造了新的元素(抽象)</strong>。如果需要添加新元素加以标识的，就是伪元素，反之，如果只需要在既有元素上添加类别的，就是伪类。伪元素在一个选择器里只能出现一次，并且只能出现在末尾。 伪类则是像真正的类一样发挥着类的作用，没有数量上的限制，只要不是相互排斥的伪类，也可以同时使用在相同的元素上。 <strong>实际使用</strong>：伪类用一个冒号表示 :first-child；伪元素则使用两个冒号表示 ::first-line</p></li><li><p><strong>CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理</strong><strong>static定位(普通流定位) -------------- 默认定位</strong><strong>float定位(浮动定位) 例：float:left</strong> 有两个取值：left(左浮动)和right(右浮动)。浮动元素会在没有浮动元素的上方，效果上看是遮挡住了没有浮动的元素，有float样式规则的元素是脱离文档流的，它的父元素的高度并不能有它撑开。 <strong>relative定位(相对定位) position:relative</strong> 相对本元素的左上角进行定位，top,left,bottom,right都可以有值。虽然经过定位后，位置可能会移动，但是本元素并没有脱离文档流，还占有原来的页面空间。可以设置z-index。使本元素相对于文档流中的元素，或者脱离文档流但是z-index的值比本元素的值要小的元素更加靠近用户的视线。 相对定位最大的作用是为了实现某个元素相对于本元素的左上角绝对定位，本元素需要设置position为relative。 <strong>absolute定位(绝对定位) position:absolute</strong> 相对于祖代中有relative(相对定位)并且离本元素层级关系上是最近的元素的左上角进行定位，如果在祖代元素中没有有relative定位的，就默认相对于body进行定位。 绝对定位是脱离文档流的，与浮动定位是一样的效果，会压在非定位元素的上方。可以设置z-index属性。 <strong>雪碧图实现原理：</strong> CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS background和background-position属性渲染，这也就意味着你的标签变得更加复杂了，图片是在CSS中定义，而非标签。</p></li><li><p><strong>写出尽可能多的水平垂直居中的方案并对比它们的优缺点</strong><strong>行内元素水平居中：</strong> 首先看它的父元素是不是块级元素，如果是，则直接给父元素设置 <strong>text-align: center;</strong> 如果不是，则先将其父元素设置为块级元素，再给父元素设置 <strong>text-align: center;</strong><strong>块级元素水平居中(定宽度)：</strong> 需要谁居中，给其设置 margin: 0 auto; （作用：使盒子自己居中） 首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的<strong>left:50%</strong>，即让子元素的左上角水平居中； 设置绝对子元素的 <strong>margin-left: -元素宽度的一半px;</strong> 或者设置<strong>transform: translateX(-50%);</strong><strong>块级元素水平居中(不宽度)：</strong></p><ol><li>默认子元素的宽度和父元素一样，这时需要设置子元素为display: inline-block; 或 display: inline;即将其转换成行内块级/行内元素，给父元素设置 text-align: center;</li><li>首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的<strong>left:50%</strong>，即让子元素的左上角水平居中； 利用css3新增属性<strong>transform: translateX(-50%);</strong><strong>使用flexbox布局实现水平居中（宽度定不定都可以）:</strong> 使用flexbox布局，只需要给待处理的块状元素的父元素添加属性 display: flex; justify-content: center; <strong>单行的行内元素垂直居中:</strong> 只需要设置单行行内元素的&quot;行高等于盒子的高&quot;即可； <strong>多行的行内元素垂直居中:</strong> 使用给父元素设置<strong>display:table-cell;<strong>和</strong>vertical-align: middle;<strong>属即可； <strong>块级元素垂直居中方法一：使用定位</strong> 首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的</strong>top: 50%</strong>，即让子元素的左上角垂直居中； <strong>定高度：<strong>设置绝对子元素的 <strong>margin-top: -元素高度的一半px;</strong> 或者设置</strong>transform: translateY(-50%);</strong><strong>不定高度：<strong>利用css3新增属性</strong>transform: translateY(-50%);</strong><strong>块级元素垂直居中</strong>方法二：使用flexbox布局实现（高度定不定都可以）** 使用flexbox布局，只需要给待处理的块状元素的父元素添加属性 <strong>display: flex; align-items: center;</strong><strong>水平垂直居中-已知高度和宽度的元素：</strong><strong>方法一：</strong> 设置父元素为相对定位，给子元素设置绝对定位，<strong>top: 0; right: 0; bottom: 0; left: 0; margin: auto;</strong><strong>方法二：</strong> 设置父元素为相对定位，给子元素设置绝对定位，<strong>left: 50%; top: 50%; margin-left: -<strong><strong>-元素宽度的一半px</strong></strong>; margin-top: -<strong><strong>-元素高度的一半px</strong></strong>;</strong><strong>水平垂直居中</strong>-<strong>未知高度和宽度的元素：</strong><strong>方法一：使用定位属性</strong> 设置父元素为相对定位，给子元素设置绝对定位，<strong>left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%);</strong><strong>方案二：使用flex布局实现</strong> 设置父元素为flex定位，<strong>justify-content: center; align-items: center;</strong></li></ol></li><li><p><strong>BFC的布局规则，实现原理，可以解决的问题</strong> BFC直译为<strong>块级格式化上下文</strong>，它是一个独立的渲染区域，只有Block-level box参与，它规定了<strong>内部的Block-level Box</strong>如何布局，并且与外部毫不相干。<br><strong>注意</strong>：可以把BFC理解为一个大的盒子，其内部是由Block-level box组成的 <strong>BFC布局规则</strong>：</p><ul><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算 <strong>BFC的作用</strong>：</li></ul><ol><li><strong>自适应两栏布局</strong></li><li><strong>清除内部浮动</strong></li><li><strong>防止垂直margin重叠</strong><code>BFC</code>内部的元素和外部的元素绝对不会互相影响，因此， 当<code>BFC</code>外部存在浮动时，它不应该影响<code>BFC</code>内部Box的布局，<code>BFC</code>会通过变窄，而不与浮动有重叠。同样的，当<code>BFC</code>内部有浮动时，为了不影响外部元素的布局，<code>BFC</code>计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。</li></ol></li><li><p><strong>CSS函数有哪些</strong>？ 属性函数：attr() 背景图片函数：linear-gradient()、radial-gradient()、conic-gradient()、repeating-linear-gradient()、repeating-radial-gradient()、repeating-conic-gradient()、image-set()、image()、url()、element()； 颜色函数：rgb()、rgba()、hsl()、hsla()、hwb()、color-mod()； 图形函数：circle()、ellipse()、inset()、polygon()、path() 滤镜函数：blur()、brightness()、contrast()、drop-shadow()、grayscale()、hue-rotate()、invert()、opacity()、saturate()、sepia()； 转换函数：matrix()、matrix3d()、perspective()、rotate()、rotate3d()、rotateX()、rotateY()、rotateZ()、scale()、scale3d()、scaleX()、scaleY()、scaleZ()、skew()、skewX()、skewY()、translate()、translateX()、translateY()、translateZ()、translate3d()； 数学函数：calc()、min()、max()、mixmax()、repeat()； 缓动函数：cubic-bezier()、steps()； 其他函数：counter()、counters()、toggle()、var()、 symbols()。</p></li><li><p><strong>PostCSS、Sass、Less的异同，以及使用配置，至少掌握一种</strong> ● 编译环境不一样，Sass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中；  ● 变量符号不一样，Less是@，而Scss是$；  ● 输出设置，Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded；  ● 处理条件语句，Sass支持条件语句，可以使用if{}else{},for{}循环等等。 LESS的条件语句使用有些另类，他不是我们常见的关键词if和else if之类，而其实现方式是利用关键词“when”；  ● 引用外部文件，文件名如果以下划线_开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件，ess引用外部文件和css中的@import没什么差异；  ● 工具库的不同，Sass有工具库Compass, 简单说，Sass和Compass的关系有点像Javascript和jQuery的关系,Compass在Sass的基础上，封装了一系列有用的模块和模板，补充强化了Sass的功能。Less有UI组件库Bootstrap,Bootstrap是web前端开发中一个比较有名的前端UI组件库，Bootstrap的样式文件部分源码就是采用Less语法编写。    ● PostCSS介绍： PostCSS 的主要功能只有两个：第一个就是前面提到的把 CSS 解析成 JavaScript 可以操作的 AST，第二个就是调用插件来处理 AST 并得到结果。因此，不能简单的把 PostCSS 归类成 CSS 预处理或后处理工具。PostCSS 所能执行的任务非常多，同时涵盖了传统意义上的预处理和后处理。  ● PostCSS使用 PostCSS 一般不单独使用，而是与已有的构建工具进行集成。PostCSS 与主流的构建工具，如 Webpack、Grunt 和 Gulp 都可以进行集成。完成集成之后，选择满足功能需求的 PostCSS 插件并进行配置。现在经常用到的是基于PostCSS的Autoprefixer插件，使用方式可以在官网的插件库进行查询。下面是官网地址： <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.postcss.com.cn%2F" title="https://www.postcss.com.cn/" target="_blank" rel="noreferrer">PostCSS官网地址</a></p></li><li><p>a</p></li><li></li></ol>',3)]))}const S=o(e,[["render",i]]);export{m as __pageData,S as default};
