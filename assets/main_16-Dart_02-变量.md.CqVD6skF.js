import{_ as a,c as i,o as e,ae as t}from"./chunks/framework.Dgg8-8ov.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"main/16-Dart/02-变量.md","filePath":"main/16-Dart/02-变量.md","lastUpdated":1751603324000}'),n={name:"main/16-Dart/02-变量.md"};function l(o,s,r,d,h,c){return e(),i("div",null,s[0]||(s[0]=[t(`<p>可以使用var来声明局部变量，而不是使用准确的类型。根据内容判断类型。 <code>var name = ‘Bob’</code><code>String name = ‘Bob’</code></p><h3 id="空安全" tabindex="-1">空安全 <a class="header-anchor" href="#空安全" aria-label="Permalink to &quot;空安全&quot;">​</a></h3><p>Dart 语言要求以健全的空安全方式编写代码。对于 <code>toString()</code> 方法和 <code>hashCode</code> 属性，空安全会体现出例外情况。</p><ol><li>当为变量、参数或另一个相关组件指定类型时，可以控制该类型是否允许 <code>null</code> 。要让一个变量可以为空，可以在类型声明的末尾添加 <code>?</code> 。<code>String?name</code></li><li>必须在使用变量之前对其进行初始化。可空变量是默认初始化为 <code>null</code> 的。 Dart 不会为非可空类型设置初始值，它强制要求设置初始值。 Dart 不允许观察未初始化的变量。这可以防止在接收者类型可以为 <code>null</code> 但 <code>null</code> 不支持的相关方法或属性的情况下使用它。</li><li>不能在可空类型的表达式上访问属性或调用方法。同样的例外情况适用于 <code>null</code> 支持的属性或方法，例如 <code>hashCode</code> 或 <code>toString()</code> 。 空安全将潜在的 <strong>运行时错误</strong> 转变为 <strong>编辑时</strong> 分析错误。当非空变量处于以下任一状态时，空安全会识别该变量：未使用非空值进行初始化，赋值为<code>null</code></li></ol><h3 id="默认值" tabindex="-1">默认值 <a class="header-anchor" href="#默认值" aria-label="Permalink to &quot;默认值&quot;">​</a></h3><p>具有可空类型的未初始化变量的初始值为 <code>null</code> 。即使是具有数值类型的变量，初始值也为空，因为数字（就像 Dart 中的其他所有东西一样）都是对象。 在生产环境中运行代码时，<code>assert()</code> 调用会被忽略。另外在开发过程中，<code>assert(_condition_)</code> 如果其 <strong>条件</strong> 为 false，会抛出一个异常。 必须在使用非空变量之前初始化它们的值。 不必在声明变量时初始化变量，但在使用之前需要为其赋值。 顶级变量和类变量是延迟初始化的，它们会在第一次被使用时再初始化。</p><h3 id="延迟初始化变量" tabindex="-1">延迟初始化变量 <a class="header-anchor" href="#延迟初始化变量" aria-label="Permalink to &quot;延迟初始化变量&quot;">​</a></h3><p><code>late</code>修饰符两种用法：声明非空变量，但不在声明初始化和延迟初始化一个变量。 通常 Dart 的语义分析可以检测非空变量在使用之前是否被赋值，但有时会分析失败。常见的两种情况是在分析顶级变量和实例变量时，Dart 通常无法确定它们是否已设值，因此不会尝试分析。 确定变量在使用之前已设置，但 Dart 推断错误的话，可以将变量标记为 <code>late</code> 来解决这个问题。 如果没有初始化一个 <code>late</code> 变量，那么当变量被使用时会发生运行时错误。 当一个 <code>late</code> 修饰的变量在声明时就指定了初始化方法，那么内容会在第一次使用变量时运行初始化。这种延迟初始化在以下情况很方便：</p><ul><li>（Dart 推断）可能不需要该变量，并且初始化它的开销很高。</li><li>正在初始化一个实例变量，它的初始化方法需要调用 <code>this</code>。</li></ul><h3 id="终值-final-和常量-const" tabindex="-1">终值 (final) 和常量 (const) <a class="header-anchor" href="#终值-final-和常量-const" aria-label="Permalink to &quot;终值 (final) 和常量 (const)&quot;">​</a></h3><p>如果不打算更改一个变量，可以使用 <code>final</code> 或 <code>const</code> 修饰它，而不是使用 <code>var</code> 或作为类型附加。一个 final 变量只能设置一次，const 变量是编译时常量。（const 常量隐式包含了 final。） <a href="https://dart.cn/language/classes#instance-variables" target="_blank" rel="noreferrer">实例变量</a> 可以是 <code>final</code> 但不能是 <code>const</code>。 请使用 <code>const</code> 修饰 <strong>编译时常量</strong> 的变量。 <code>const</code> 关键字不仅仅可用于声明常量，你还可以使用它来创建常量 <strong>值(values)</strong>，以及声明 <strong>创建(create)</strong> 常量值的构造函数。任何变量都可以拥有常量值。 <code>const</code> 关键字不仅仅可用于声明常量，你还可以使用它来创建常量 <strong>值(values)</strong>，以及声明 <strong>创建(create)</strong> 常量值的构造函数。任何变量都可以拥有常量值。 如果一个变量没被声明为 <code>final</code> 或者 <code>const</code>，那么，即使它的值是 <code>const</code>，仍然可以修改这个变量。不能修改 <code>const</code> 变量的。 可以在定义常量时使用 <a href="https://dart.cn/language/operators#type-test-operators" target="_blank" rel="noreferrer">类型检查和转换</a>（<code>is</code> 和 <code>as</code>）、 <a href="https://dart.cn/language/collections#control-flow-operators" target="_blank" rel="noreferrer">集合中的 <code>if</code></a> 和 <a href="https://dart.cn/language/collections#spread-operators" target="_blank" rel="noreferrer">展开操作符</a>（<code>...</code> 和 <code>...?</code>）</p><div class="language-dart vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//这是一个const对象 伴随着一个int值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//为list[]的值定义了一个int类型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> map </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;int&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//使用和收集</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> set</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;...list)}; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 传播</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>虽然 <code>final</code> 对象不能被修改，但它的字段可能可以被更改。相比之下，<code>const</code> 对象及其字段不能被更改：它们是 <strong>不可变的</strong>。</p><h3 id="wildcard-variables-通配符变量" tabindex="-1">Wildcard variables 通配符变量 <a class="header-anchor" href="#wildcard-variables-通配符变量" aria-label="Permalink to &quot;Wildcard variables 通配符变量&quot;">​</a></h3>`,14)]))}const g=a(n,[["render",l]]);export{k as __pageData,g as default};
