import{_ as e,c as t,o as d,ae as l}from"./chunks/framework.Dh1jimFm.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{"date":"2025-04-29T00:00:00.000Z","tags":["js"]},"headers":[],"relativePath":"main/浏览器：文档，事件，接口/Document/遍历 DOM.md","filePath":"main/浏览器：文档，事件，接口/Document/遍历 DOM.md","lastUpdated":1746186059000}'),c={name:"main/浏览器：文档，事件，接口/Document/遍历 DOM.md"};function i(n,o,r,g,s,a){return d(),t("div",null,o[0]||(o[0]=[l("<p>DOM 让我们可以对元素和它们中的内容做任何事，但是首先我们需要获取到对应的 DOM 对象。 对 DOM 的所有操作都是以 <code>document</code> 对象开始。它是 DOM 的主“入口点”。从它我们可以访问任何节点。</p><ol><li>在最顶层：documentElement 和 body <ol><li>最顶层的树节点可以直接作为 <code>document</code> 的属性来使用： <ol><li><code>&lt;html&gt;</code> = <code>document.documentElement</code></li><li>最顶层的 document 节点是 <code>document.documentElement</code>。这是对应 <code>&lt;html&gt;</code> 标签的 DOM 节点。</li><li><code>&lt;body&gt;</code> = <code>document.body</code></li><li>另一个被广泛使用的 DOM 节点是 <code>&lt;body&gt;</code> 元素 —— <code>document.body</code>。</li><li><code>&lt;head&gt;</code> = <code>document.head</code></li><li><code>&lt;head&gt;</code> 标签可以通过 <code>document.head</code> 访问。</li></ol></li><li>这里有个问题：<code>document.body</code> 的值可能是 <code>null</code><ol><li>脚本无法访问在运行时不存在的元素。</li><li>尤其是，如果一个脚本是在 <code>&lt;head&gt;</code> 中，那么脚本是访问不到 <code>document.body</code> 元素的，因为浏览器还没有读到它。</li></ol></li></ol></li><li><strong>子节点：childNodes，firstChild，lastChild</strong><ol><li><ul><li><strong>子节点（或者叫作子）</strong> —— 对应的是直系的子元素。换句话说，它们被完全嵌套在给定的元素中。例如，<code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 就是 <code>&lt;html&gt;</code> 元素的子元素。</li></ul></li><li><ul><li><strong>子孙元素</strong> —— 嵌套在给定元素中的所有元素，包括子元素，以及子元素的子元素等。</li></ul></li><li><strong><code>childNodes</code> 集合列出了所有子节点，包括文本节点。</strong></li><li><strong><code>firstChild</code> 和 <code>lastChild</code> 属性是访问第一个和最后一个子元素的快捷方式。</strong></li></ol></li><li><strong>DOM 集合</strong><ol><li>正如我们看到的那样，<code>childNodes</code> 看起来就像一个数组。但实际上它并不是一个数组，而是一个 <strong>集合</strong> —— 一个类数组的可迭代对象。 <ol><li>我们可以使用 <code>for..of</code> 来迭代它</li><li>无法使用数组的方法，因为它不是一个数组</li></ol></li><li><strong>DOM 集合是只读的</strong><ol><li>DOM 集合，甚至可以说本章中列出的 <strong>所有</strong> 导航（navigation）属性都是只读的。</li><li>我们不能通过类似 <code>childNodes[i] = ...</code> 的操作来替换一个子节点。</li></ol></li><li><strong>DOM 集合是实时的</strong><ol><li>除小部分例外，几乎所有的 DOM 集合都是 <strong>实时</strong> 的。换句话说，它们反映了 DOM 的当前状态。</li><li>如果我们保留一个对 <code>elem.childNodes</code> 的引用，然后向 DOM 中添加/移除节点，那么这些节点的更新会自动出现在集合中。</li></ol></li><li><strong>不要使用 <code>for..in</code> 来遍历集合</strong><ol><li>可以使用 <code>for..of</code> 对集合进行迭代。但有时候人们会尝试使用 <code>for..in</code> 来迭代集合。</li></ol></li></ol></li><li><strong>兄弟节点和父节点</strong><ol><li><strong>兄弟节点（sibling）</strong> 是指有同一个父节点的节点。<code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 就是兄弟节点。</li></ol></li><li><strong>纯元素导航</strong><ol><li>上面列出的导航（navigation）属性引用 <strong>所有</strong> 节点。例如，在 <code>childNodes</code> 中我们可以看到文本节点，元素节点，甚至包括注释节点（如果它们存在的话）。</li><li><code>parentElement</code> 属性返回的是“元素类型”的父节点，而 <code>parentNode</code> 返回的是“任何类型”的父节点。这些属性通常来说是一样的：它们都是用于获取父节点。</li></ol></li><li><strong>更多链接：表格</strong><ol><li><p><strong><code>&lt;table&gt;</code></strong> 元素支持 (除了上面给出的，之外) 以下属性 - <code>table.rows</code> —— <code>&lt;tr&gt;</code> 元素的集合。</p><ul><li><code>table.caption/tHead/tFoot</code> —— 引用元素 <code>&lt;caption&gt;</code>，<code>&lt;thead&gt;</code>，<code>&lt;tfoot&gt;</code>。</li><li><code>table.tBodies</code> —— <code>&lt;tbody&gt;</code> 元素的集合（根据标准还有很多元素，但是这里至少会有一个 —— 即使没有被写在 HTML 源文件中，浏览器也会将其放入 DOM 中）。</li></ul><p><strong><code>&lt;thead&gt;</code>，<code>&lt;tfoot&gt;</code>，<code>&lt;tbody&gt;</code></strong> 元素提供了 <code>rows</code> 属性：</p><ul><li><code>tbody.rows</code> —— 表格内部 <code>&lt;tr&gt;</code> 元素的集合。</li></ul><p><strong><code>&lt;tr&gt;</code>：</strong></p><ul><li><code>tr.cells</code> —— 在给定 <code>&lt;tr&gt;</code> 中的 <code>&lt;td&gt;</code> 和 <code>&lt;th&gt;</code> 单元格的集合。</li><li><code>tr.sectionRowIndex</code> —— 给定的 <code>&lt;tr&gt;</code> 在封闭的 <code>&lt;thead&gt;/&lt;tbody&gt;/&lt;tfoot&gt;</code> 中的位置（索引）。</li><li><code>tr.rowIndex</code> —— 在整个表格中 <code>&lt;tr&gt;</code> 的编号（包括表格的所有行）。</li></ul><p><strong><code>&lt;td&gt;</code> 和 <code>&lt;th&gt;</code>：</strong></p><ul><li><code>td.cellIndex</code> —— 在封闭的 <code>&lt;tr&gt;</code> 中单元格的编号。</li></ul></li></ol></li></ol>",2)]))}const h=e(c,[["render",i]]);export{u as __pageData,h as default};
