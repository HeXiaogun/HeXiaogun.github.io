import{_ as o,c as t,o as r,ae as c}from"./chunks/framework.Dh1jimFm.js";const n=JSON.parse('{"title":"","description":"","frontmatter":{"date":"2025-04-25T00:00:00.000Z","tags":["js"]},"headers":[],"relativePath":"main/JS/原型，继承/原型方法，没有 __proto__ 的对象.md","filePath":"main/JS/原型，继承/原型方法，没有 __proto__ 的对象.md","lastUpdated":1746068392000}'),l={name:"main/JS/原型，继承/原型方法，没有 __proto__ 的对象.md"};function _(d,e,a,i,p,s){return r(),t("div",null,e[0]||(e[0]=[c('<ul><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="noreferrer">Object.getPrototypeOf(obj)</a> —— 返回对象 <code>obj</code> 的 <code>[[Prototype]]</code>。</li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noreferrer">Object.setPrototypeOf(obj, proto)</a> —— 将对象 <code>obj</code> 的 <code>[[Prototype]]</code> 设置为 <code>proto</code>。</li><li><ul><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noreferrer">Object.create(proto, [descriptors])</a> —— 利用给定的 <code>proto</code> 作为 <code>[[Prototype]]</code> 和可选的属性描述来创建一个空对象。</li></ul></li></ul><ol><li><strong>原型简史</strong><ol><li><ul><li>构造函数的 <code>&quot;prototype&quot;</code> 属性自古以来就起作用。这是使用给定原型创建对象的最古老的方式。</li></ul></li><li><ul><li>之后，在 2012 年，<code>Object.create</code> 出现在标准中。它提供了使用给定原型创建对象的能力。但没有提供 get/set 它的能力。一些浏览器实现了非标准的 <code>__proto__</code> 访问器，以为开发者提供更多的灵活性。</li></ul></li><li><ul><li>之后，在 2015 年，<code>Object.setPrototypeOf</code> 和 <code>Object.getPrototypeOf</code> 被加入到标准中，执行与 <code>__proto__</code> 相同的功能。由于 <code>__proto__</code> 实际上已经在所有地方都得到了实现，但它已过时，所以被加入到该标准的附件 B 中，即：在非浏览器环境下，它的支持是可选的。</li></ul></li><li><ul><li>之后，在 2022 年，官方允许在对象字面量 <code>{...}</code> 中使用 <code>__proto__</code>（从附录 B 中移出来了），但不能用作 getter/setter <code>obj.__proto__</code>（仍在附录 B 中）。</li></ul></li><li>如果速度很重要，就请不要修改已存在的对象的 <code>[[Prototype]]</code></li></ol></li><li><strong>&quot;Very plain&quot; objects</strong><ol><li>对象可以用作关联数组（associative arrays）来存储键/值对。</li></ol></li><li>设置和访问原型的现代方法有 - - <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="noreferrer">Object.getPrototypeOf(obj)</a> —— 返回对象 <code>obj</code> 的 <code>[[Prototype]]</code>（与 <code>__proto__</code> 的 getter 相同）。 <ul><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noreferrer">Object.setPrototypeOf(obj, proto)</a> —— 将对象 <code>obj</code> 的 <code>[[Prototype]]</code> 设置为 <code>proto</code>（与 <code>__proto__</code> 的 setter 相同）。</li><li>不推荐使用内建的 <code>__proto__</code> getter/setter 获取/设置原型，它现在在 ECMA 规范的附录 B 中。</li><li>我们还介绍了使用 <code>Object.create(null)</code> 或 <code>{__proto__: null}</code> 创建的无原型的对象。</li></ul></li></ol>',2)]))}const f=o(l,[["render",_]]);export{n as __pageData,f as default};
