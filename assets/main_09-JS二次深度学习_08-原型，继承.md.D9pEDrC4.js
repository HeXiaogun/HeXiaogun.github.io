import{_ as a,c as n,o as e,ae as i}from"./chunks/framework.Dgg8-8ov.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{"tags":["js"]},"headers":[],"relativePath":"main/09-JS二次深度学习/08-原型，继承.md","filePath":"main/09-JS二次深度学习/08-原型，继承.md","lastUpdated":1747318796000}'),l={name:"main/09-JS二次深度学习/08-原型，继承.md"};function t(p,s,o,r,c,d){return e(),n("div",null,s[0]||(s[0]=[i(`<h2 id="原型继承" tabindex="-1">原型继承 <a class="header-anchor" href="#原型继承" aria-label="Permalink to &quot;原型继承&quot;">​</a></h2><p><strong>原型继承（Prototypal inheritance）</strong> 这个语言特性能够帮助我们实现这一需求。</p><ol><li><code>[[Prototype]]</code><ol><li>在 JavaScript 中，对象有一个特殊的隐藏属性 <code>[[Prototype]]</code>（如规范中所命名的），它要么为 <code>null</code>，要么就是对另一个对象的引用。该对象被称为“原型”：</li><li>从 <code>object</code> 中读取一个缺失的属性时，JavaScript 会自动从原型中获取该属性。在编程中，这被称为“原型继承”。</li><li>属性 <code>[[Prototype]]</code> 是内部的而且是隐藏的，但是这儿有很多设置它的方式。</li></ol><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> animal </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  eats: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rabbit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  jumps: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rabbit.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> animal; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置 rabbit.[[Prototype]] = animal</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//“\`animal\` 是 \`rabbit\` 的原型”，或者说 “\`rabbit\` 的原型是从 \`animal\` 继承而来的”。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>	1. \`__proto__\` 是 \`[[Prototype]]\` 的因历史原因而留下来的 getter/setter</span></span>
<span class="line"><span>	2. \`__proto__\` 与内部的 \`[[Prototype]]\` **不一样**。\`__proto__\` 是 \`[[Prototype]]\` 的 getter/setter。</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>2. **写入不使用原型**</span></span>
<span class="line"><span>	1. 原型仅用于读取属性。对于写入/删除操作可以直接在对象上进行。</span></span>
<span class="line"><span>\`\`\`JavaScript</span></span>
<span class="line"><span>	let animal = {</span></span>
<span class="line"><span>	  eats: true,</span></span>
<span class="line"><span>	  walk() {</span></span>
<span class="line"><span>	    /* rabbit 不会使用此方法 */</span></span>
<span class="line"><span>	  }</span></span>
<span class="line"><span>	};</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	let rabbit = {</span></span>
<span class="line"><span>	  __proto__: animal</span></span>
<span class="line"><span>	};</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	rabbit.walk = function() {</span></span>
<span class="line"><span>	  alert(&quot;Rabbit! Bounce-bounce!&quot;);</span></span>
<span class="line"><span>	};</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	rabbit.walk(); // Rabbit! Bounce-bounce!</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><ol start="3"><li><strong>“this” 的值</strong><ol><li><strong>无论在哪里找到方法：在一个对象还是在原型中。在一个方法调用中，<code>this</code> 始终是点符号 <code>.</code> 前面的对象。</strong></li></ol></li><li><strong>for…in 循环</strong><ol><li><code>for..in</code> 循环也会迭代继承的属性。</li></ol></li></ol><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> animal </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  eats: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rabbit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  jumps: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	  __proto__: animal</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// Object.keys 只返回自己的 key</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">keys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rabbit)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// jumps</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// for..in 会遍历自己以及继承的键</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rabbit) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(prop); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// jumps，然后是 eats</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="f-prototype" tabindex="-1">F.prototype <a class="header-anchor" href="#f-prototype" aria-label="Permalink to &quot;F.prototype&quot;">​</a></h2><p>如果 <code>F.prototype</code> 是一个对象，那么 <code>new</code> 操作符会使用它为新对象设置 <code>[[Prototype]]</code>。</p><ol><li>JavaScript 从一开始就有了原型继承。这是 JavaScript 编程语言的核心特性之一。</li><li><strong>默认的 F.prototype，构造器属性</strong><ol><li>每个函数都有 <code>&quot;prototype&quot;</code> 属性，即使我们没有提供它。</li><li>默认的 <code>&quot;prototype&quot;</code> 是一个只有属性 <code>constructor</code> 的对象，属性 <code>constructor</code> 指向函数自身。</li><li><strong>……JavaScript 自身并不能确保正确的 <code>&quot;constructor&quot;</code> 函数值。</strong></li><li></li></ol></li></ol><h2 id="原生的原型" tabindex="-1">原生的原型 <a class="header-anchor" href="#原生的原型" aria-label="Permalink to &quot;原生的原型&quot;">​</a></h2><p>&quot;prototype&quot; 属性在 JavaScript 自身的核心部分中被广泛地应用。所有的内建构造函数都用到了它。</p><ol><li><strong>Object.prototype</strong><ol><li>let obj = {}; alert( obj ); // &quot;[object Object]&quot; ?</li><li><code>obj = {}</code> 和 <code>obj = new Object()</code> 是一个意思，其中 <code>Object</code> 就是一个内建的对象构造函数，其自身的 <code>prototype</code> 指向一个带有 <code>toString</code> 和其他方法的一个巨大的对象。</li></ol></li><li><strong>其他内建原型</strong><ol><li>其他内建对象，像 <code>Array</code>、<code>Date</code>、<code>Function</code> 及其他，都在 prototype 上挂载了方法。</li></ol></li><li><strong>基本数据类型</strong><ol><li>最复杂的事情发生在字符串、数字和布尔值上。</li><li>值 <code>null</code> 和 <code>undefined</code> 没有对象包装器</li></ol></li><li><strong>更改原生原型</strong><ol><li>重要： <ol><li>原型是全局的，所以很容易造成冲突。如果有两个库都添加了 <code>String.prototype.show</code> 方法，那么其中的一个方法将被另一个覆盖。</li><li><strong>在现代编程中，只有一种情况下允许修改原生原型。那就是 polyfilling。</strong></li><li>Polyfilling 是一个术语，表示某个方法在 JavaScript 规范中已存在，但是特定的 JavaScript 引擎尚不支持该方法，那么我们可以通过手动实现它，并用以填充内建原型。</li></ol></li></ol></li><li><strong>从原型中借用</strong><ol><li>那是指我们从一个对象获取一个方法，并将其复制到另一个对象。一些原生原型的方法通常会被借用。</li><li></li></ol></li></ol><h2 id="原型方法-没有-proto-的对象" tabindex="-1">原型方法，没有 <strong>proto</strong> 的对象 <a class="header-anchor" href="#原型方法-没有-proto-的对象" aria-label="Permalink to &quot;原型方法，没有 __proto__ 的对象&quot;">​</a></h2><ul><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="noreferrer">Object.getPrototypeOf(obj)</a> —— 返回对象 <code>obj</code> 的 <code>[[Prototype]]</code>。</li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noreferrer">Object.setPrototypeOf(obj, proto)</a> —— 将对象 <code>obj</code> 的 <code>[[Prototype]]</code> 设置为 <code>proto</code>。</li><li><ul><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noreferrer">Object.create(proto, [descriptors])</a> —— 利用给定的 <code>proto</code> 作为 <code>[[Prototype]]</code> 和可选的属性描述来创建一个空对象。</li></ul></li></ul><ol><li><strong>原型简史</strong><ol><li><ul><li>构造函数的 <code>&quot;prototype&quot;</code> 属性自古以来就起作用。这是使用给定原型创建对象的最古老的方式。</li></ul></li><li><ul><li>之后，在 2012 年，<code>Object.create</code> 出现在标准中。它提供了使用给定原型创建对象的能力。但没有提供 get/set 它的能力。一些浏览器实现了非标准的 <code>__proto__</code> 访问器，以为开发者提供更多的灵活性。</li></ul></li><li><ul><li>之后，在 2015 年，<code>Object.setPrototypeOf</code> 和 <code>Object.getPrototypeOf</code> 被加入到标准中，执行与 <code>__proto__</code> 相同的功能。由于 <code>__proto__</code> 实际上已经在所有地方都得到了实现，但它已过时，所以被加入到该标准的附件 B 中，即：在非浏览器环境下，它的支持是可选的。</li></ul></li><li><ul><li>之后，在 2022 年，官方允许在对象字面量 <code>{...}</code> 中使用 <code>__proto__</code>（从附录 B 中移出来了），但不能用作 getter/setter <code>obj.__proto__</code>（仍在附录 B 中）。</li></ul></li><li>如果速度很重要，就请不要修改已存在的对象的 <code>[[Prototype]]</code></li></ol></li><li><strong>&quot;Very plain&quot; objects</strong><ol><li>对象可以用作关联数组（associative arrays）来存储键/值对。</li></ol></li><li>设置和访问原型的现代方法有 - - <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="noreferrer">Object.getPrototypeOf(obj)</a> —— 返回对象 <code>obj</code> 的 <code>[[Prototype]]</code>（与 <code>__proto__</code> 的 getter 相同）。 <ul><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noreferrer">Object.setPrototypeOf(obj, proto)</a> —— 将对象 <code>obj</code> 的 <code>[[Prototype]]</code> 设置为 <code>proto</code>（与 <code>__proto__</code> 的 setter 相同）。</li><li>不推荐使用内建的 <code>__proto__</code> getter/setter 获取/设置原型，它现在在 ECMA 规范的附录 B 中。</li><li>我们还介绍了使用 <code>Object.create(null)</code> 或 <code>{__proto__: null}</code> 创建的无原型的对象。</li></ul></li></ol>`,15)]))}const k=a(l,[["render",t]]);export{b as __pageData,k as default};
