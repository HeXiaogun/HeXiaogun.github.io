import{_ as o,c as l,o as r,ae as i}from"./chunks/framework.Dh1jimFm.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{"date":"2025-04-26T00:00:00.000Z","tags":["js"]},"headers":[],"relativePath":"main/JS/Promise，async，await/Promise API.md","filePath":"main/JS/Promise，async，await/Promise API.md","lastUpdated":1746068392000}'),s={name:"main/JS/Promise，async，await/Promise API.md"};function t(c,e,d,a,m,n){return r(),l("div",null,e[0]||(e[0]=[i("<p>在 <code>Promise</code> 类中，有 6 种静态方法。</p><ol><li><strong>Promise.all</strong><ol><li>let promise = Promise.all(iterable);</li><li>希望并行执行多个 promise，并等待所有 promise 都准备就绪。</li><li><code>Promise.all</code> 接受一个可迭代对象（通常是一个数组项为 promise 的数组），并返回一个新的 promise。</li><li><strong>如果任意一个 promise 被 reject，由 <code>Promise.all</code> 返回的 promise 就会立即 reject，并且带有的就是这个 error。</strong></li><li><code>Promise.all(iterable)</code> 允许在 <code>iterable</code> 中使用非 promise 的“常规”值</li></ol></li><li><strong>Promise.allSettled</strong><ol><li><code>Promise.allSettled</code> 等待所有的 promise 都被 settle，无论结果如何。结果数组会是这样的 <ul><li>对成功的响应，结果数组对应元素的内容为 <code>{status:&quot;fulfilled&quot;, value:result}</code>，</li><li>对出现 error 的响应，结果数组对应元素的内容为 <code>{status:&quot;rejected&quot;, reason:error}</code>。</li></ul></li></ol></li><li><strong>Polyfill</strong><ol><li>如果浏览器不支持 <code>Promise.allSettled</code>，很容易进行 polyfill</li><li>这个处理程序将成功的结果 <code>value</code> 转换为 <code>{status:&#39;fulfilled&#39;, value}</code>，将 error <code>reason</code> 转换为 <code>{status:&#39;rejected&#39;, reason}</code>。这正是 <code>Promise.allSettled</code> 的格式。</li><li>我们就可以使用 <code>Promise.allSettled</code> 来获取 <strong>所有</strong> 给定的 promise 的结果，即使其中一些被 reject。</li></ol></li><li><strong>Promise.race</strong><ol><li>与 <code>Promise.all</code> 类似，但只等待第一个 settled 的 promise 并获取其结果（或 error）。</li><li>let promise = Promise.race(iterable);</li></ol></li><li><strong>Promise.any</strong><ol><li>1与 <code>Promise.race</code> 类似，区别在于 <code>Promise.any</code> 只等待第一个 fulfilled 的 promise，并将这个 fulfilled 的 promise 返回。</li><li>let promise = Promise.any(iterable);</li></ol></li><li><strong>Promise.resolve/reject</strong><ol><li>很少需要使用 <code>Promise.resolve</code> 和 <code>Promise.reject</code> 方法，因为 <code>async/await</code> 语法 <ol><li><strong>Promise.resolve</strong><ol><li><code>Promise.resolve(value)</code> 用结果 <code>value</code> 创建一个 resolved 的 promise。</li><li>let promise = new Promise(resolve =&gt; resolve(value));</li></ol></li><li><strong>Promise.reject</strong><ol><li><code>Promise.reject(error)</code> 用 <code>error</code> 创建一个 rejected 的 promise。</li><li>let promise = new Promise((resolve, reject) =&gt; reject(error));</li></ol></li></ol></li></ol></li></ol>",2)]))}const u=o(s,[["render",t]]);export{p as __pageData,u as default};
