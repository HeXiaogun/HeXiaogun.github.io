import{_ as s,c as t,o as a,ae as l}from"./chunks/framework.Dgg8-8ov.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"main/面试题/html相关.md","filePath":"main/面试题/html相关.md","lastUpdated":1747923153000}'),n={name:"main/面试题/html相关.md"};function e(r,i,o,d,p,h){return a(),t("div",null,i[0]||(i[0]=[l(`<ol><li><p><strong>行级元素和块级元素分别有哪些？怎么转换？</strong> 常见的块级元素：p，div，form，ul，li，ol，table，h1，d1，dt，dd 常见的行级元素：span，a，img，button，input，select <strong>块级元素</strong>：</p><ul><li>总是在新行上开始，就是每个块级元素独占一行，默认从上到下排列</li><li>宽度缺少时是它的容器的100%，除非设置一个宽度</li><li>高度、行高以及外边距和内边距都是可以设置的</li><li>块级元素可以容纳其它行级元素和块级元素 <strong>行内元素</strong>：</li><li>和其它元素都会在一行显示</li><li>高、行高以及外边距和内边距可以设置</li><li>宽度就是文字或者图片的宽度，不能改变</li><li>行级元素只能容纳文本或者其它行内元素 <strong>使用行内元素需要注意的</strong>：</li><li>行内元素设置宽度<code>width</code>无效</li><li>行内元素设置<code>height</code>无效，但是可以通过<code>line-height</code>来设置</li><li>设置<code>margin</code>只有左右有效，上下无效</li><li>设置<code>padding</code>只有左右有效，上下无效 <strong>补充</strong>：img、button、input、select，这些是替换元素，默认是display:inline-block,可以进行宽高的设置</li></ul><p>可以通过<code>display</code>属性对行内元素和块级元素进行切换(主要看第 <code>2、3、4</code>三个值)</p></li><li><p><strong>H5有哪些新元素和特性？</strong> HTML5主要是关于图像、位置、存储、多任务等功能的增加：</p><ul><li>语义化标签，如：article、footer、header、nav等</li><li>视频video、音频audio</li><li>画布canvas</li><li>表单控件，calemdar、date、time、email</li><li>地理</li><li>本地离线存储，localStorage长期存储数据，浏览器关闭后数据不丢失，sessionStorage的数据在浏览器关闭后自动删除</li><li>拖拽释放</li></ul></li><li><p><strong>如何使用HTML5中的Canvas元素绘制图形？</strong> Canvas元素允许在网页上使用JavaScript绘制图形和动画。</p><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">canvas</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myCanvas&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;200&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;200&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">canvas</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> canvas </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myCanvas&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ctx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> canvas.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2d&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.fillStyle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;red&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fillRect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>以上示例：使用 <code>document.getElementById()</code> 方法获取 <code>Canvas</code> 元素，并通过 <code>getContext(“2d”)</code> 获取2D绘图上下文。 然后，使用 <code>fillStyle</code> 属性设置填充颜色，<code>fillRect()</code> 方法绘制一个矩形。</p></li><li><p><strong>cookie、sessionStorage和localStorage的区别</strong></p></li></ol><table tabindex="0"><thead><tr><th></th><th>cookie</th><th>LocalStorage</th><th>sessionStorage</th></tr></thead><tbody><tr><td><strong>由谁初始化</strong></td><td>客户端或服务器，服务器可以使用 <code>Set-Cookie</code> 请求头。</td><td>客户端</td><td>客户端</td></tr><tr><td><strong>过期时间</strong></td><td>手动设置</td><td>永不过期</td><td>当页面关闭时</td></tr><tr><td><strong>在当前浏览器会话（browser sessions）中是否保持不变</strong></td><td>是，Cookies 会通过 <code>Cookie</code> 请求头，自动发送给服务器</td><td>否</td><td>否</td></tr><tr><td><strong>容量（每个域名）</strong></td><td>4kb</td><td>5MB</td><td>5MB</td></tr><tr><td><strong>访问权限</strong></td><td>任意窗口</td><td>任意窗口</td><td>当前窗口</td></tr></tbody></table><ol start="5"><li><p><strong>script、script async和scriptdefer的区别</strong></p><ul><li><code>&lt;script&gt;</code> - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。</li><li><code>&lt;script async&gt;</code> - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用 <code>async</code>，比如用作页面统计分析。</li><li><code>&lt;script defer&gt;</code> - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含 <code>defer</code> 的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。 <strong>注意</strong>：没有 <code>src</code> 属性的脚本，<code>async</code> 和 <code>defer</code> 属性会被忽略。</li></ul></li><li><p><strong>什么是DOCTYPE，有什么作用</strong> DOCTYPE是HTML5的文档声明通过它告诉浏览器使用哪一个HTML版本的标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为<code>怪异模式</code>，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的<code>bug</code>，所以文档声明是必须的。</p></li><li><p><strong>对html语义化的理解</strong> HTML标签的语义化，简单来说，就是用正确的标签做正确的事情，给某块内容用上一个最恰当最合适的标签，使页面有良好的结构，页面元素有含义，无论是谁都能看懂这块内容是什么。 语义化的优点： - 在没有CSS样式情况下也能够让页面呈现出清晰的结构 - 有利于SEO和搜索引擎建立良好的沟通，有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重 - 方便团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化</p></li><li><p><strong>什么是严格模式和混杂模式</strong><strong>严格模式</strong>：是以浏览器支持的最高标准运行 <strong>混杂模式</strong>：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为</p></li><li><p><strong>前端页面有那三层构成，分别是什么</strong><strong>结构层、表示层、行为层</strong> 结构层：类似于盖房子需要打地基以及房子的悬梁框架，它是由HTML超文本标记语言来创建的，也就是页面中的各种标签，在结构层中保存了用户可以看到的所有内容，比如说：一段文字、一张图片、一段视频等等 表示层：表示层是由CSS负责创建，它的作用是如何显示有关内容，学名：<code>层叠样式表</code>，也就相当于装修房子，看你要什么风格的，田园的、中式的、地中海的，总之CSS都能办妥 行为层：行为层表示网页内容跟用户之间产生交互性，简单来说就是用户操作了网页，网页给用户一个反馈，这是<code>JavaScript</code>和<code>DOM</code>主宰的领域</p></li><li><p><strong>iframe的作用以及缺点</strong><strong>优点</strong>：</p><ul><li>可以在页面上独立显示一个页面或者内容,不会与页面其他元素产生冲突。</li><li>可以在多个页面中重用同一个页面或者内容,可以减少代码的冗余。</li><li>加载是异步的,页面可以在不等待 iframe 加载完成的情况下进行展示。</li><li>方便地实现跨域访问 <strong>缺点</strong>：</li><li>搜索引擎可能无法正确解析 iframe 中的内容</li><li>会阻塞主页面的 onload 事件</li><li>和主页面共享连接池,影响页面并行加载 <strong>补充</strong>： iframe默认是同步加载的，但是浏览器会优化，使用并行加载，也就是iframe的加载可能会与其他的资源并行加载，但是这个并行加载仅是网络请求阶段，所以iframe还是会阻塞onload事件</li></ul></li><li><p><strong>对于Web标准和W3C的理解</strong><strong>Web标准</strong>：简单来说可以分为结构、表现、行为。其中结构是由HTML各种标签组成，简单来说就是body里面写入标签是为了页面的结构。表现指的是CSS层叠样式表，通过CSS可以让我们的页面结构标签更具美感。行为指的是页面和用户具有一定的交互，这部分主要由JS组成 <strong>W3C</strong>：全称：world wide web consortium。是一个制定各种标准的非盈利性组织，也叫万维网联盟，标准包括HTML、CSS、ECMAScript等等，web标准的制定有很多好处，比如说： - 可以统一开发流程，统一使用标准化开发工具（VSCode、WebStorm、Sublime），方便多人协作 - 学习成本降低，只需要学习标准就行，否则就要学习各个浏览器厂商标准 - 跨平台，方便迁移都不同设备 - 降低代码维护成本</p></li><li><p><strong>Quirks（怪癖）模式是什么？它和Standars（标准）有什么区别</strong> 页面如果写了DTD，就意味着这个页面采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式，这就是Quirks模式，有时候也叫怪癖模式、诡异模式、怪异模式。 <strong>区别</strong>：总体会有布局、样式解析、脚本执行三个方面区别，这里列举一些比较常见的区别：</p><ul><li><strong>盒模型</strong>：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，然而在Quirks模式下，IE的宽度和高度还包含了padding和border</li><li><strong>设置行内元素的高宽</strong>：在Standards模式下，给行内元素设置width和height都不会生效，而在Quriks模式下会生效</li><li><strong>用margin：0 auto设置水平居中</strong>：在Standards模式下，设置<code>margin：0 auto</code>，可以使元素水平居中，但是在Quriks模式下失效</li><li><strong>设置百分比高度</strong>：在Standards模式下，元素的高度是由包含的内容决定的，如果父元素没有设置百分比的高度，子元素设置百分比的高度是无效的</li></ul></li><li><p><strong>meta viewport是做什么用的，怎么写？</strong> Viewport，适配移动端，可以控制视口的大小和比例： <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</code><strong>content的参数有</strong>：</p><ul><li>width viewport ：宽度(数值/device-width)</li><li>height viewport ：高度(数值/device-height)</li><li>initial-scale ：初始缩放比例</li><li>maximum-scale ：最大缩放比例</li><li>minimum-scale ：最小缩放比例</li><li>user-scalable ：是否允许用户缩放(yes/no）</li></ul></li></ol>`,3)]))}const c=s(n,[["render",e]]);export{g as __pageData,c as default};
