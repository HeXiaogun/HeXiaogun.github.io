import{_ as e,c as l,o as r,ae as i}from"./chunks/framework.Dh1jimFm.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{"date":"2025-04-26T00:00:00.000Z","tags":["js"]},"headers":[],"relativePath":"main/JS/模块/模块 (Module) 简介.md","filePath":"main/JS/模块/模块 (Module) 简介.md","lastUpdated":1746068392000}'),t={name:"main/JS/模块/模块 (Module) 简介.md"};function n(a,o,s,d,c,g){return r(),l("div",null,o[0]||(o[0]=[i('<ul><li><a href="https://en.wikipedia.org/wiki/Asynchronous_module_definition" target="_blank" rel="noreferrer">AMD</a> —— 最古老的模块系统之一，最初由 <a href="http://requirejs.org/" target="_blank" rel="noreferrer">require.js</a> 库实现。</li><li><a href="http://wiki.commonjs.org/wiki/Modules/1.1" target="_blank" rel="noreferrer">CommonJS</a> —— 为 Node.js 服务器创建的模块系统。</li><li><a href="https://github.com/umdjs/umd" target="_blank" rel="noreferrer">UMD</a> —— 另外一个模块系统，建议作为通用的模块系统，它与 AMD 和 CommonJS 都兼容。</li></ul><ol><li><strong>什么是模块？</strong><ol><li>一个模块（module）就是一个文件。一个脚本就是一个模块。</li><li>模块可以相互加载，并可以使用特殊的指令 <code>export</code> 和 <code>import</code> 来交换功能</li><li>模块只通过 HTTP(s) 工作，而非本地</li></ol></li><li><strong>模块核心功能</strong><ol><li>始终使用 “use strict”</li><li><strong>模块级作用域</strong><ol><li>每个模块都有自己的顶级作用域（top-level scope）。换句话说，一个模块中的顶级作用域变量和函数在其他脚本中是不可见的。</li></ol></li><li><strong>模块代码仅在第一次导入时被解析</strong><ol><li>如果同一个模块被导入到多个其他位置，那么它的代码只会执行一次，即在第一次被导入时。</li></ol></li></ol></li><li><strong>import.meta</strong><ol><li><code>import.meta</code> 对象包含关于当前模块的信息。 <ol><li>alert(import.meta.url); // 脚本的 URL</li></ol></li><li><strong>在一个模块中，“this” 是 undefined</strong></li></ol></li><li><strong>浏览器特定功能</strong><ol><li>与常规脚本相比，拥有 <code>type=&quot;module&quot;</code> 标识的脚本有一些特定于浏览器的差异。</li><li><strong>模块脚本是延迟的</strong></li><li><strong>Async 适用于内联脚本（inline script）</strong></li><li><strong>外部脚本</strong><ol><li>具有 <code>type=&quot;module&quot;</code> 的外部脚本（external script）在两个方面有所不同 <ol><li>具有相同 <code>src</code> 的外部脚本仅运行一次</li><li>从另一个源（例如另一个网站）获取的外部脚本需要 <a href="https://developer.mozilla.org/zh/docs/Web/HTTP/CORS" target="_blank" rel="noreferrer">CORS</a> header，如我们在 <a href="https://zh.javascript.info/fetch-crossorigin" target="_blank" rel="noreferrer">Fetch：跨源请求</a> 一章中所讲的那样。换句话说，如果一个模块脚本是从另一个源获取的，则远程服务器必须提供表示允许获取的 header <code>Access-Control-Allow-Origin</code>。</li></ol></li></ol></li><li><strong>不允许裸模块（“bare” module）</strong><ol><li>在浏览器中，<code>import</code> 必须给出相对或绝对的 URL 路径。没有任何路径的模块被称为“裸（bare）”模块。在 <code>import</code> 中不允许这种模块。</li></ol></li><li><strong>兼容性，“nomodule”</strong><ol><li>旧时的浏览器不理解 <code>type=&quot;module&quot;</code>。未知类型的脚本会被忽略。对此，我们可以使用 <code>nomodule</code> 特性来提供一个后备</li></ol></li></ol></li><li><strong>构建工具</strong><ol><li>常，我们会使用一些特殊工具，例如 <a href="https://webpack.js.org/" target="_blank" rel="noreferrer">Webpack</a>，将它们打包在一起，然后部署到生产环境的服务器。 它们可以更好地控制模块的解析方式，允许我们使用裸模块和更多的功能</li><li>构建工具做以下这些事儿 <ol><li>从一个打算放在 HTML 中的 <code>&lt;script type=&quot;module&quot;&gt;</code> “主”模块开始。</li><li>分析它的依赖：它的导入，以及它的导入的导入等。</li><li>使用所有模块构建一个文件（或者多个文件，这是可调的），并用打包函数（bundler function）替代原生的 <code>import</code> 调用，以使其正常工作。还支持像 HTML/CSS 模块等“特殊”的模块类型。</li><li>在处理过程中，可能会应用其他转换和优化： <ul><li>删除无法访问的代码。</li><li>删除未使用的导出（“tree-shaking”）。</li><li>删除特定于开发的像 <code>console</code> 和 <code>debugger</code> 这样的语句。</li><li>可以使用 <a href="https://babeljs.io/" target="_blank" rel="noreferrer">Babel</a> 将前沿的现代的 JavaScript 语法转换为具有类似功能的旧的 JavaScript 语法。</li><li>压缩生成的文件（删除空格，用短的名字替换变量等）。</li></ul></li></ol></li></ol></li></ol>',2)]))}const m=e(t,[["render",n]]);export{u as __pageData,m as default};
