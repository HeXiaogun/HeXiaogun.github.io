import{_ as i,c as e,o as t,ae as a}from"./chunks/framework.Dh1jimFm.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{"date":"2025-04-25T00:00:00.000Z","tags":["js"]},"headers":[],"relativePath":"main/函数进阶内容/调度：setTimeout 和 setInterval.md","filePath":"main/函数进阶内容/调度：setTimeout 和 setInterval.md","lastUpdated":1746186059000}'),l={name:"main/函数进阶内容/调度：setTimeout 和 setInterval.md"};function n(r,s,o,p,d,h){return t(),e("div",null,s[0]||(s[0]=[a(`<p>有时我们并不想立即执行一个函数，而是等待特定一段时间之后再执行。这就是所谓的“计划调用（scheduling a call）”。</p><ul><li><code>setTimeout</code> 允许我们将函数推迟到一段时间间隔之后再执行。</li><li><code>setInterval</code> 允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。</li><li>参数都是毫秒单位</li></ul><ol><li><strong>setTimeout</strong><ol><li>let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...) <ol><li><strong><code>func|code</code></strong>：想要执行的函数或代码字符串。 一般传入的都是函数。由于某些历史原因，支持传入代码字符串，但是不建议这样做。使用函数名，而不是函数名( ),因为这里是引用函数，不是执行函数</li><li><strong><code>delay</code></strong>：执行前的延时，以毫秒为单位（1000 毫秒 = 1 秒），默认值是 0；</li><li><strong><code>arg1</code>，<code>arg2</code>…</strong>：要传入被执行函数（或代码字符串）的参数列表（IE9 以下不支持）</li></ol></li></ol></li><li><strong>用 clearTimeout 来取消调度</strong> 1. <code>setTimeout</code> 在调用时会返回一个“定时器标识符（timer identifier）”，在我们的例子中是 <code>timerId</code>，我们可以使用 clearTimeout 来取消执行。</li></ol><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timerId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;never happens&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timerId); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定时器标识符</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		clearTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timerId);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timerId); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 还是这个标识符（并没有因为调度被取消了而变成 null）</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="3"><li><strong>setInterval</strong><ol><li><code>setInterval</code> 方法和 <code>setTimeout</code> 的语法相同：</li><li>let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)</li><li>与 <code>setTimeout</code> 只执行一次不同，<code>setInterval</code> 是每间隔给定的时间周期性执行。</li></ol></li><li><strong>嵌套的 setTimeout</strong><ol><li>周期性调度有两种方式：一种是使用 <code>setInterval</code>，另外一种就是嵌套的 <code>setTimeout</code>，</li><li><strong>嵌套的 <code>setTimeout</code> 相较于 <code>setInterval</code> 能够更精确地设置两次执行之间的延时。</strong></li><li><strong>使用 <code>setInterval</code> 时，<code>func</code> 函数的实际调用间隔要比代码中设定的时间间隔要短！</strong></li><li><strong>嵌套的 <code>setTimeout</code> 就能确保延时的固定</strong></li><li>垃圾回收和 setInterval/setTimeout 回调（callback）：当一个函数传入 <code>setInterval/setTimeout</code> 时，将为其创建一个内部引用，并保存在调度程序中。这样，即使这个函数没有其他引用，也能防止垃圾回收器（GC）将其回收。</li></ol></li><li><strong>零延时的 setTimeout</strong><ol><li>特殊的用法：<code>setTimeout(func, 0)</code>，或者仅仅是 <code>setTimeout(func)</code>。</li><li>这样调度可以让 <code>func</code> 尽快执行。但是只有在当前正在执行的脚本执行完成后，调度程序才会调用它。也就是说，该函数被调度在当前脚本执行完成“之后”立即执行。</li><li><strong>零延时实际上不为零（在浏览器中）</strong><ol><li>根据 <a href="https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers" target="_blank" rel="noreferrer">HTML5 标准</a> 所讲：“经过 5 重嵌套定时器之后，时间间隔被强制设定为至少 4 毫秒”。</li><li></li></ol></li></ol></li></ol><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;World&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	//会先输出 “Hello”，然后立即输出 “World”</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div>`,6)]))}const g=i(l,[["render",n]]);export{k as __pageData,g as default};
