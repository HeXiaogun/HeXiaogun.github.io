import{_ as t,c as e,o as r,ae as c}from"./chunks/framework.Dh1jimFm.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{"date":"2025-04-25T00:00:00.000Z","tags":["js"]},"headers":[],"relativePath":"main/原型，继承/F.prototype.md","filePath":"main/原型，继承/F.prototype.md","lastUpdated":1746186059000}'),a={name:"main/原型，继承/F.prototype.md"};function p(d,o,i,n,s,l){return r(),e("div",null,o[0]||(o[0]=[c("<p>如果 <code>F.prototype</code> 是一个对象，那么 <code>new</code> 操作符会使用它为新对象设置 <code>[[Prototype]]</code>。</p><ol><li>JavaScript 从一开始就有了原型继承。这是 JavaScript 编程语言的核心特性之一。</li><li><strong>默认的 F.prototype，构造器属性</strong><ol><li>每个函数都有 <code>&quot;prototype&quot;</code> 属性，即使我们没有提供它。</li><li>默认的 <code>&quot;prototype&quot;</code> 是一个只有属性 <code>constructor</code> 的对象，属性 <code>constructor</code> 指向函数自身。</li><li><strong>……JavaScript 自身并不能确保正确的 <code>&quot;constructor&quot;</code> 函数值。</strong></li><li></li></ol></li></ol>",2)]))}const m=t(a,[["render",p]]);export{u as __pageData,m as default};
