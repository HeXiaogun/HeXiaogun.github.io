import{_ as i,c as o,o as e,ae as d}from"./chunks/framework.Dh1jimFm.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{"date":"2025-04-28T00:00:00.000Z","tags":["js"]},"headers":[],"relativePath":"main/JS/杂项/BigInt.md","filePath":"main/JS/杂项/BigInt.md","lastUpdated":1746068392000}'),l={name:"main/JS/杂项/BigInt.md"};function n(c,t,a,r,g,s){return e(),o("div",null,t[0]||(t[0]=[d('<p><code>BigInt</code> 是一种特殊的数字类型，它提供了对任意长度整数的支持。 创建 bigint 的方式有两种：在一个整数字面量后面加 <code>n</code> 或者调用 <code>BigInt</code> 函数，该函数从字符串、数字等中生成 bigint。</p><ol><li><strong>数学运算符</strong><ol><li>对 bigint 的所有操作，返回的结果也是 bigint。</li><li>如果有其他需要，我们应该显式地转换它们：使用 <code>BigInt()</code> 或者 <code>Number()</code>，</li></ol></li><li><strong>BigInt 不支持一元加法</strong><ol><li>一元加法运算符 <code>+value</code>，是大家熟知的将 <code>value</code> 转换成数字类型的方法。</li></ol></li><li><strong>比较运算符</strong><ol><li>比较运算符，例如 <code>&lt;</code> 和 <code>&gt;</code>，使用它们来对 bigint 和 number 类型的数字进行比较没有问题</li><li>但是请注意，由于 number 和 bigint 属于不同类型，它们可能在进行 <code>==</code> 比较时相等，但在进行 <code>===</code>（严格相等）比较时不相等</li></ol></li><li><strong>布尔运算</strong><ol><li>当在 <code>if</code> 或其他布尔运算中时，bigint 的行为类似于 number。</li></ol></li><li><strong>Polyfill</strong><ol><li>Polyfilling bigint 比较棘手。原因是许多 JavaScript 运算符，比如 <code>+</code> 和 <code>-</code> 等，在对待 bigint 的行为上与常规 number 相比有所不同。 <ol><li>例如，bigint 的除法总是返回 bigint（如果需要，会进行舍入）。</li></ol></li></ol></li></ol><table tabindex="0"><thead><tr><th>运算</th><th>原生 BigInt</th><th>JSBI</th></tr></thead><tbody><tr><td>从 Number 创建</td><td>a = BigInt(789)</td><td>a = JSBI.BigInt(789)</td></tr><tr><td>加法</td><td>c = a + b</td><td>c = JSBI.add(a, b)</td></tr><tr><td>减法</td><td>c = a - b</td><td>c = JSBI.subtract(a, b)</td></tr></tbody></table>',3)]))}const m=i(l,[["render",n]]);export{_ as __pageData,m as default};
