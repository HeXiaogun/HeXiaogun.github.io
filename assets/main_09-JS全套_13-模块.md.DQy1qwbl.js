import{_ as i,c as l,o as a,ae as n}from"./chunks/framework.Dh1jimFm.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{"tags":["js"]},"headers":[],"relativePath":"main/09-JS全套/13-模块.md","filePath":"main/09-JS全套/13-模块.md","lastUpdated":1746369197000}'),e={name:"main/09-JS全套/13-模块.md"};function t(o,s,r,p,h,d){return a(),l("div",null,s[0]||(s[0]=[n(`<h2 id="模块-module-简介" tabindex="-1">模块 (Module) 简介 <a class="header-anchor" href="#模块-module-简介" aria-label="Permalink to &quot;模块 (Module) 简介&quot;">​</a></h2><ul><li><a href="https://en.wikipedia.org/wiki/Asynchronous_module_definition" target="_blank" rel="noreferrer">AMD</a> —— 最古老的模块系统之一，最初由 <a href="http://requirejs.org/" target="_blank" rel="noreferrer">require.js</a> 库实现。</li><li><a href="http://wiki.commonjs.org/wiki/Modules/1.1" target="_blank" rel="noreferrer">CommonJS</a> —— 为 Node.js 服务器创建的模块系统。</li><li><a href="https://github.com/umdjs/umd" target="_blank" rel="noreferrer">UMD</a> —— 另外一个模块系统，建议作为通用的模块系统，它与 AMD 和 CommonJS 都兼容。</li></ul><ol><li><strong>什么是模块？</strong><ol><li>一个模块（module）就是一个文件。一个脚本就是一个模块。</li><li>模块可以相互加载，并可以使用特殊的指令 <code>export</code> 和 <code>import</code> 来交换功能</li><li>模块只通过 HTTP(s) 工作，而非本地</li></ol></li><li><strong>模块核心功能</strong><ol><li>始终使用 “use strict”</li><li><strong>模块级作用域</strong><ol><li>每个模块都有自己的顶级作用域（top-level scope）。换句话说，一个模块中的顶级作用域变量和函数在其他脚本中是不可见的。</li></ol></li><li><strong>模块代码仅在第一次导入时被解析</strong><ol><li>如果同一个模块被导入到多个其他位置，那么它的代码只会执行一次，即在第一次被导入时。</li></ol></li></ol></li><li><strong>import.meta</strong><ol><li><code>import.meta</code> 对象包含关于当前模块的信息。 <ol><li>alert(import.meta.url); // 脚本的 URL</li></ol></li><li><strong>在一个模块中，“this” 是 undefined</strong></li></ol></li><li><strong>浏览器特定功能</strong><ol><li>与常规脚本相比，拥有 <code>type=&quot;module&quot;</code> 标识的脚本有一些特定于浏览器的差异。</li><li><strong>模块脚本是延迟的</strong></li><li><strong>Async 适用于内联脚本（inline script）</strong></li><li><strong>外部脚本</strong><ol><li>具有 <code>type=&quot;module&quot;</code> 的外部脚本（external script）在两个方面有所不同 <ol><li>具有相同 <code>src</code> 的外部脚本仅运行一次</li><li>从另一个源（例如另一个网站）获取的外部脚本需要 <a href="https://developer.mozilla.org/zh/docs/Web/HTTP/CORS" target="_blank" rel="noreferrer">CORS</a> header，如我们在 <a href="https://zh.javascript.info/fetch-crossorigin" target="_blank" rel="noreferrer">Fetch：跨源请求</a> 一章中所讲的那样。换句话说，如果一个模块脚本是从另一个源获取的，则远程服务器必须提供表示允许获取的 header <code>Access-Control-Allow-Origin</code>。</li></ol></li></ol></li><li><strong>不允许裸模块（“bare” module）</strong><ol><li>在浏览器中，<code>import</code> 必须给出相对或绝对的 URL 路径。没有任何路径的模块被称为“裸（bare）”模块。在 <code>import</code> 中不允许这种模块。</li></ol></li><li><strong>兼容性，“nomodule”</strong><ol><li>旧时的浏览器不理解 <code>type=&quot;module&quot;</code>。未知类型的脚本会被忽略。对此，我们可以使用 <code>nomodule</code> 特性来提供一个后备</li></ol></li></ol></li><li><strong>构建工具</strong><ol><li>常，我们会使用一些特殊工具，例如 <a href="https://webpack.js.org/" target="_blank" rel="noreferrer">Webpack</a>，将它们打包在一起，然后部署到生产环境的服务器。 它们可以更好地控制模块的解析方式，允许我们使用裸模块和更多的功能</li><li>构建工具做以下这些事儿 <ol><li>从一个打算放在 HTML 中的 <code>&lt;script type=&quot;module&quot;&gt;</code> “主”模块开始。</li><li>分析它的依赖：它的导入，以及它的导入的导入等。</li><li>使用所有模块构建一个文件（或者多个文件，这是可调的），并用打包函数（bundler function）替代原生的 <code>import</code> 调用，以使其正常工作。还支持像 HTML/CSS 模块等“特殊”的模块类型。</li><li>在处理过程中，可能会应用其他转换和优化： <ul><li>删除无法访问的代码。</li><li>删除未使用的导出（“tree-shaking”）。</li><li>删除特定于开发的像 <code>console</code> 和 <code>debugger</code> 这样的语句。</li><li>可以使用 <a href="https://babeljs.io/" target="_blank" rel="noreferrer">Babel</a> 将前沿的现代的 JavaScript 语法转换为具有类似功能的旧的 JavaScript 语法。</li><li>压缩生成的文件（删除空格，用短的名字替换变量等）。</li></ul></li></ol></li></ol></li></ol><h2 id="导出和导入" tabindex="-1">导出和导入 <a class="header-anchor" href="#导出和导入" aria-label="Permalink to &quot;导出和导入&quot;">​</a></h2><ol><li><strong>在声明前导出</strong><ol><li>我们可以通过在声明之前放置 <code>export</code> 来标记任意声明为导出，无论声明的是变量，函数还是类都可以。</li><li>导出 class/function 后没有分号</li></ol></li><li><strong>导出与声明分开</strong></li><li><strong>Import <code>*</code></strong><ol><li>通常，我们把要导入的东西列在花括号 <code>import {...}</code> 中</li><li>但是如果有很多要导入的内容，我们可以使用 <code>import * as &lt;obj&gt;</code> 将所有内容导入为一个对象</li></ol></li><li><strong>Import “as”</strong> 取个别名 <ol><li>也可以使用 <code>as</code> 让导入具有不同的名字。</li><li>import {sayHi as hi, sayBye as bye} from &#39;./say.js&#39;;</li></ol></li><li><strong>Export “as”</strong> 取个别名 <ol><li>export {sayHi as hi, sayBye as bye};</li></ol></li><li><strong>Export default</strong><ul><li>包含库或函数包的模块，像上面的 <code>say.js</code>。</li><li>声明单个实体的模块，例如模块 <code>user.js</code> 仅导出 <code>class User</code>。</li></ul></li><li><strong>“default” 名称</strong><ol><li>在某些情况下，<code>default</code> 关键词被用于引用默认的导出。</li></ol></li><li><strong>我应该使用默认的导出吗？</strong><ol><li>命名的导出是明确的。它们确切地命名了它们要导出的内容，因此我们能从它们获得这些信息，这是一件好事。</li></ol></li><li><strong>重新导出</strong><ol><li>“重新导出（Re-export）”语法 <code>export ... from ...</code> 允许导入内容，并立即将其导出（可能是用的是其他的名字）</li></ol></li><li><strong>重新导出默认导出</strong><ol><li>要重新导出默认导出，我们必须明确写出 <code>export {default as User}</code>，</li></ol></li></ol><h2 id="动态导入" tabindex="-1">动态导入 <a class="header-anchor" href="#动态导入" aria-label="Permalink to &quot;动态导入&quot;">​</a></h2><p>我们不能动态生成 <code>import</code> 的任何参数。</p><ol><li><strong>import() 表达式</strong><ol><li><code>import(module)</code> 表达式加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块对象。我们可以在代码中的任意位置调用这个表达式。</li></ol></li></ol><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> modulePath </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> prompt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Which module to load?&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(modulePath)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">module</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .catch(err =&gt; &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">loading</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> error,</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> e.g.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> if</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> no</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> such</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">// 📁 say.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">export function hi() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Hello\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">export function bye() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Bye\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let {hi, bye} = await import(&#39;./say.js&#39;);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hi();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bye();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div>`,9)]))}const g=i(e,[["render",t]]);export{k as __pageData,g as default};
