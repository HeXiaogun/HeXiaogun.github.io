import{_ as o,c,o as r,ae as t}from"./chunks/framework.Dh1jimFm.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{"date":"2025-04-25T00:00:00.000Z","tags":["js"]},"headers":[],"relativePath":"main/JS/类/扩展内建类.md","filePath":"main/JS/类/扩展内建类.md","lastUpdated":1746068392000}'),d={name:"main/JS/类/扩展内建类.md"};function a(i,e,s,l,n,_){return r(),c("div",null,e[0]||(e[0]=[t('<p>内建的类，例如 <code>Array</code>，<code>Map</code> 等也都是可以扩展的（extendable）。 内建的方法例如 <code>filter</code>，<code>map</code> 等 —— 返回的正是子类 <code>PowerArray</code> 的新对象。它们内部使用了对象的 <code>constructor</code> 属性来实现这一功能 当 <code>arr.filter()</code> 被调用时，它的内部使用的是 <code>arr.constructor</code> 来创建新的结果数组，而不是使用原生的 <code>Array</code>。这真的很酷，因为我们可以在结果数组上继续使用 <code>PowerArray</code> 的方法。 我们可以给这个类添加一个特殊的静态 getter <code>Symbol.species</code>，它会返回 JavaScript 在内部用来在 <code>map</code> 和 <code>filter</code> 等方法中创建新实体的 <code>constructor</code>。</p><ol><li><strong>其他集合的工作方式类似</strong><ol><li>其他集合，例如 <code>Map</code> 和 <code>Set</code> 的工作方式类似。它们也使用 <code>Symbol.species</code>。</li></ol></li><li><strong>内建类没有静态方法继承</strong><ol><li>内建对象有它们自己的静态方法，例如 <code>Object.keys</code>，<code>Array.isArray</code> 等。</li><li>当一个类扩展另一个类时，静态方法和非静态方法都会被继承。这已经在 <a href="https://zh.javascript.info/static-properties-methods#statics-and-inheritance" target="_blank" rel="noreferrer">静态属性和静态方法</a> 中详细地解释过了。</li><li></li></ol></li></ol>',2)]))}const f=o(d,[["render",a]]);export{m as __pageData,f as default};
