import{_ as l,c as o,o as i,ae as t}from"./chunks/framework.DvccZNqS.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{"tags":["js"]},"headers":[],"relativePath":"main/09-JS二次深度学习/15-Document.md","filePath":"main/09-JS二次深度学习/15-Document.md","lastUpdated":1747318796000}'),d={name:"main/09-JS二次深度学习/15-Document.md"};function s(c,e,n,a,r,g){return i(),o("div",null,e[0]||(e[0]=[t(`<h2 id="浏览器环境-规格" tabindex="-1">浏览器环境，规格 <a class="header-anchor" href="#浏览器环境-规格" aria-label="Permalink to &quot;浏览器环境，规格&quot;">​</a></h2><p>平台可以是一个浏览器，一个 Web 服务器，或其他 <strong>主机（host）</strong>，甚至可以是一个“智能”咖啡机，如果它能运行 JavaScript 的话。它们每个都提供了特定于平台的功能。JavaScript 规范将其称为 <strong>主机环境</strong>。</p><ol><li>有一个叫做 <code>window</code> 的“根”对象。它有两个角色： <ol><li><ol><li>首先，它是 JavaScript 代码的全局对象，如 <a href="https://zh.javascript.info/global-object" target="_blank" rel="noreferrer">全局对象</a> 一章所述。</li></ol></li><li><ol><li>其次，它代表“浏览器窗口”，并提供了控制它的方法。</li></ol></li></ol></li><li><strong>文档对象模型（DOM）</strong><ol><li>文档对象模型（Document Object Model），简称 DOM，将所有页面内容表示为可以修改的对象。</li><li><code>document</code> 对象是页面的主要“入口点”。我们可以使用它来更改或创建页面上的任何内容。</li><li>DOM 规范解释了文档的结构，并提供了操作文档的对象。有的非浏览器设备也使用 DOM。</li></ol></li><li><strong>浏览器对象模型（BOM）</strong><ol><li>浏览器对象模型（Browser Object Model），简称 BOM，表示由浏览器（主机环境）提供的用于处理文档（document）之外的所有内容的其他对象。 <ol><li><ul><li><a href="https://developer.mozilla.org/zh/docs/Web/API/Window/navigator" target="_blank" rel="noreferrer">navigator</a> 对象提供了有关浏览器和操作系统的背景信息。navigator 有许多属性，但是最广为人知的两个属性是：<code>navigator.userAgent</code> —— 关于当前浏览器，<code>navigator.platform</code> —— 关于平台（有助于区分 Windows/Linux/Mac 等）。</li></ul></li><li><ul><li><a href="https://developer.mozilla.org/zh/docs/Web/API/Window/location" target="_blank" rel="noreferrer">location</a> 对象允许我们读取当前 URL，并且可以将浏览器重定向到新的 URL。</li></ul></li></ol></li><li>BOM 是通用 <a href="https://html.spec.whatwg.org/" target="_blank" rel="noreferrer">HTML 规范</a> 的一部分。</li></ol></li></ol><h2 id="dom-树" tabindex="-1">DOM 树 <a class="header-anchor" href="#dom-树" aria-label="Permalink to &quot;DOM 树&quot;">​</a></h2><p><strong>HTML 文档的主干是标签（tag）。</strong> 根据文档对象模型（DOM），每个 HTML 标签都是一个对象。嵌套的标签是闭合标签的“子标签（children）”。标签内的文本也是一个对象。 所有这些对象都可以通过 JavaScript 来访问，我们可以使用它们来修改页面。</p><ol><li><strong>一些标签</strong><ol><li><code>document.body</code> 是表示 <code>&lt;body&gt;</code> 标签的对象。</li><li><ul><li><code>innerHTML</code> —— 节点的 HTML 内容。</li></ul></li><li><ul><li><code>offsetWidth</code> —— 节点宽度（以像素度量）</li></ul></li><li>等等</li></ol></li><li><strong>DOM的一些知识点</strong><ol><li>标签被称为 <strong>元素节点</strong>（或者仅仅是元素），并形成了树状结构：<code>&lt;html&gt;</code> 在根节点，<code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 是其子项，等。</li><li>元素内的文本形成 <strong>文本节点</strong>，被标记为 <code>＃text</code>。一个文本节点只包含一个字符串。它没有子项，并且总是树的叶子。</li><li>字符串开头/结尾处的空格，以及只有空格的文本节点，通常会被工具隐藏</li></ol></li><li><strong>自动修正</strong><ol><li>如果浏览器遇到格式不正确的 HTML，它会在形成 DOM 时自动更正它。</li><li>表格永远有 <code>&lt;tbody&gt;</code></li></ol></li><li><strong>其他节点类型</strong><ol><li>除了元素和文本节点外，还有一些其他的节点类型。，例如注释</li><li><strong>HTML 中的所有内容，甚至注释，都会成为 DOM 的一部分。</strong></li><li>甚至 HTML 开头的 <code>&lt;!DOCTYPE...&gt;</code> 指令也是一个 DOM 节点</li><li><code>document</code> —— DOM 的“入口点”。</li><li>元素节点 —— HTML 标签，树构建块。</li><li>本节点 —— 包含文本。</li><li>注释 —— 有时我们可以将一些信息放入其中，它不会显示，但 JS 可以从 DOM 中读取它。</li></ol></li><li><strong>查看DOM结构</strong><ol><li>可以打开这个网页 <a href="https://zh.javascript.info/article/dom-nodes/elks.html" target="_blank" rel="noreferrer">elks.html</a>，然后打开浏览器开发工具，并切换到元素（Elements）选项卡。</li><li><ul><li><strong>Styles</strong> —— 我们可以看到按规则应用于当前元素的 CSS 规则，包括内建规则（灰色）。几乎所有内容都可以就地编辑，包括下面的方框的 dimension/margin/padding。</li></ul></li><li><ul><li><strong>Computed</strong> —— 按属性查看应用于元素的 CSS：对于每个属性，我们可以都可以看到赋予它的规则（包括 CSS 继承等）。</li></ul></li><li><ul><li><strong>Event Listeners</strong> —— 查看附加到 DOM 元素的事件侦听器（我们将在本教程的下一部分介绍它们）。</li></ul></li></ol></li><li><strong>与控制台交互</strong><ol><li>在我们处理 DOM 时，我们可能还希望对其应用 JavaScript。例如：获取一个节点并运行一些代码来修改它，以查看结果。以下是在元素（Elements）选项卡和控制台（Console）之间切换的一些技巧。 <ol><li><ul><li>在元素（Elements）选项卡中选择第一个 <code>&lt;li&gt;</code>。</li></ul></li><li><ul><li>按下 Esc —— 它将在元素（Elements）选项卡下方打开控制台（Console）。</li></ul></li></ol></li></ol></li></ol><h2 id="遍历-dom" tabindex="-1">遍历 DOM <a class="header-anchor" href="#遍历-dom" aria-label="Permalink to &quot;遍历 DOM&quot;">​</a></h2><p>DOM 让我们可以对元素和它们中的内容做任何事，但是首先我们需要获取到对应的 DOM 对象。 对 DOM 的所有操作都是以 <code>document</code> 对象开始。它是 DOM 的主“入口点”。从它我们可以访问任何节点。</p><ol><li>在最顶层：documentElement 和 body <ol><li>最顶层的树节点可以直接作为 <code>document</code> 的属性来使用： <ol><li><code>&lt;html&gt;</code> = <code>document.documentElement</code></li><li>最顶层的 document 节点是 <code>document.documentElement</code>。这是对应 <code>&lt;html&gt;</code> 标签的 DOM 节点。</li><li><code>&lt;body&gt;</code> = <code>document.body</code></li><li>另一个被广泛使用的 DOM 节点是 <code>&lt;body&gt;</code> 元素 —— <code>document.body</code>。</li><li><code>&lt;head&gt;</code> = <code>document.head</code></li><li><code>&lt;head&gt;</code> 标签可以通过 <code>document.head</code> 访问。</li></ol></li><li>这里有个问题：<code>document.body</code> 的值可能是 <code>null</code><ol><li>脚本无法访问在运行时不存在的元素。</li><li>尤其是，如果一个脚本是在 <code>&lt;head&gt;</code> 中，那么脚本是访问不到 <code>document.body</code> 元素的，因为浏览器还没有读到它。</li></ol></li></ol></li><li><strong>子节点：childNodes，firstChild，lastChild</strong><ol><li><ul><li><strong>子节点（或者叫作子）</strong> —— 对应的是直系的子元素。换句话说，它们被完全嵌套在给定的元素中。例如，<code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 就是 <code>&lt;html&gt;</code> 元素的子元素。</li></ul></li><li><ul><li><strong>子孙元素</strong> —— 嵌套在给定元素中的所有元素，包括子元素，以及子元素的子元素等。</li></ul></li><li><strong><code>childNodes</code> 集合列出了所有子节点，包括文本节点。</strong></li><li><strong><code>firstChild</code> 和 <code>lastChild</code> 属性是访问第一个和最后一个子元素的快捷方式。</strong></li></ol></li><li><strong>DOM 集合</strong><ol><li>正如我们看到的那样，<code>childNodes</code> 看起来就像一个数组。但实际上它并不是一个数组，而是一个 <strong>集合</strong> —— 一个类数组的可迭代对象。 <ol><li>我们可以使用 <code>for..of</code> 来迭代它</li><li>无法使用数组的方法，因为它不是一个数组</li></ol></li><li><strong>DOM 集合是只读的</strong><ol><li>DOM 集合，甚至可以说本章中列出的 <strong>所有</strong> 导航（navigation）属性都是只读的。</li><li>我们不能通过类似 <code>childNodes[i] = ...</code> 的操作来替换一个子节点。</li></ol></li><li><strong>DOM 集合是实时的</strong><ol><li>除小部分例外，几乎所有的 DOM 集合都是 <strong>实时</strong> 的。换句话说，它们反映了 DOM 的当前状态。</li><li>如果我们保留一个对 <code>elem.childNodes</code> 的引用，然后向 DOM 中添加/移除节点，那么这些节点的更新会自动出现在集合中。</li></ol></li><li><strong>不要使用 <code>for..in</code> 来遍历集合</strong><ol><li>可以使用 <code>for..of</code> 对集合进行迭代。但有时候人们会尝试使用 <code>for..in</code> 来迭代集合。</li></ol></li></ol></li><li><strong>兄弟节点和父节点</strong><ol><li><strong>兄弟节点（sibling）</strong> 是指有同一个父节点的节点。<code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 就是兄弟节点。</li></ol></li><li><strong>纯元素导航</strong><ol><li>上面列出的导航（navigation）属性引用 <strong>所有</strong> 节点。例如，在 <code>childNodes</code> 中我们可以看到文本节点，元素节点，甚至包括注释节点（如果它们存在的话）。</li><li><code>parentElement</code> 属性返回的是“元素类型”的父节点，而 <code>parentNode</code> 返回的是“任何类型”的父节点。这些属性通常来说是一样的：它们都是用于获取父节点。</li></ol></li><li><strong>更多链接：表格</strong><ol><li><p><strong><code>&lt;table&gt;</code></strong> 元素支持 (除了上面给出的，之外) 以下属性 - <code>table.rows</code> —— <code>&lt;tr&gt;</code> 元素的集合。</p><ul><li><code>table.caption/tHead/tFoot</code> —— 引用元素 <code>&lt;caption&gt;</code>，<code>&lt;thead&gt;</code>，<code>&lt;tfoot&gt;</code>。</li><li><code>table.tBodies</code> —— <code>&lt;tbody&gt;</code> 元素的集合（根据标准还有很多元素，但是这里至少会有一个 —— 即使没有被写在 HTML 源文件中，浏览器也会将其放入 DOM 中）。</li></ul><p><strong><code>&lt;thead&gt;</code>，<code>&lt;tfoot&gt;</code>，<code>&lt;tbody&gt;</code></strong> 元素提供了 <code>rows</code> 属性：</p><ul><li><code>tbody.rows</code> —— 表格内部 <code>&lt;tr&gt;</code> 元素的集合。</li></ul><p><strong><code>&lt;tr&gt;</code>：</strong></p><ul><li><code>tr.cells</code> —— 在给定 <code>&lt;tr&gt;</code> 中的 <code>&lt;td&gt;</code> 和 <code>&lt;th&gt;</code> 单元格的集合。</li><li><code>tr.sectionRowIndex</code> —— 给定的 <code>&lt;tr&gt;</code> 在封闭的 <code>&lt;thead&gt;/&lt;tbody&gt;/&lt;tfoot&gt;</code> 中的位置（索引）。</li><li><code>tr.rowIndex</code> —— 在整个表格中 <code>&lt;tr&gt;</code> 的编号（包括表格的所有行）。</li></ul><p><strong><code>&lt;td&gt;</code> 和 <code>&lt;th&gt;</code>：</strong></p><ul><li><code>td.cellIndex</code> —— 在封闭的 <code>&lt;tr&gt;</code> 中单元格的编号。</li></ul></li></ol></li></ol><h2 id="搜索-getelement-queryselector" tabindex="-1">搜索：getElement，querySelector <a class="header-anchor" href="#搜索-getelement-queryselector" aria-label="Permalink to &quot;搜索：getElement，querySelector&quot;">​</a></h2><ol><li><strong>document.getElementById 或者只使用 id</strong><ol><li>如果一个元素有 <code>id</code> 特性（attribute），那我们就可以使用 <code>document.getElementById(id)</code> 方法获取该元素，无论它在哪里</li><li><strong>请不要使用以 id 命名的全局变量来访问元素</strong></li><li><strong><code>id</code> 必须是唯一的</strong></li></ol></li><li><strong>querySelectorAll</strong><ol><li>到目前为止，最通用的方法是 <code>elem.querySelectorAll(css)</code>，它返回 <code>elem</code> 中与给定 CSS 选择器匹配的所有元素。</li><li>CSS 选择器的伪类，例如 <code>:hover</code> 和 <code>:active</code> 也都是被支持的。</li></ol></li><li><strong>querySelector</strong><ol><li><code>elem.querySelector(css)</code> 调用会返回给定 CSS 选择器的第一个元素。</li><li>换句话说，结果与 <code>elem.querySelectorAll(css)[0]</code> 相同，但是后者会查找 <strong>所有</strong> 元素，并从中选取一个，而 <code>elem.querySelector</code> 只会查找一个。因此它在速度上更快，并且写起来更短。</li></ol></li><li><strong>matches</strong><ol><li><a href="https://dom.spec.whatwg.org/#dom-element-matches" target="_blank" rel="noreferrer">elem.matches(css)</a> 不会查找任何内容，它只会检查 <code>elem</code> 是否与给定的 CSS 选择器匹配。它返回 <code>true</code> 或 <code>false</code>。</li><li>当我们遍历元素（例如数组或其他内容）并试图过滤那些我们感兴趣的元素时，这个方法会很有用。</li></ol></li><li><strong>closest</strong><ol><li>元素的祖先（ancestor）是：父级，父级的父级，它的父级等。祖先们一起组成了从元素到顶端的父级链。</li><li><code>elem.closest(css)</code> 方法会查找与 CSS 选择器匹配的最近的祖先。<code>elem</code> 自己也会被搜索。</li><li>换句话说，方法 <code>closest</code> 在元素中得到了提升，并检查每个父级。如果它与选择器匹配，则停止搜索并返回该祖先。</li></ol></li><li><strong>getElementsBy<code>*</code></strong><ul><li><code>elem.getElementsByTagName(tag)</code> 查找具有给定标签的元素，并返回它们的集合。<code>tag</code> 参数也可以是对于“任何标签”的星号 <code>&quot;*&quot;</code>。</li><li><code>elem.getElementsByClassName(className)</code> 返回具有给定CSS类的元素。</li><li><code>document.getElementsByName(name)</code> 返回在文档范围内具有给定 <code>name</code> 特性的元素。很少使用。</li></ul><ol><li>不要忘记字母 <code>&quot;s&quot;</code>！ <ol><li>调用 <code>getElementByTagName</code> 而不是 <code>getElement**s**ByTagName</code>。</li></ol></li><li>它返回的是一个集合，不是一个元素！</li></ol></li><li><strong>实时的集合</strong><ol><li>所有的 <code>&quot;getElementsBy*&quot;</code> 方法都会返回一个 <strong>实时的（live）</strong> 集合。这样的集合始终反映的是文档的当前状态，并且在文档发生更改时会“自动更新”。</li><li><code>querySelectorAll</code> 返回的是一个 <strong>静态的</strong> 集合。就像元素的固定数组。</li></ol></li></ol><h2 id="节点属性-type-tag-和-content" tabindex="-1">节点属性：type，tag 和 content <a class="header-anchor" href="#节点属性-type-tag-和-content" aria-label="Permalink to &quot;节点属性：type，tag 和 content&quot;">​</a></h2><ol><li><strong>DOM 节点类</strong><ol><li>不同的 DOM 节点可能有不同的属性。例如，标签 <code>&lt;a&gt;</code> 相对应的元素节点具有链接相关的（link-related）属性，标签 <code>&lt;input&gt;</code> 相对应的元素节点具有与输入相关的属性，等。</li><li>每个 DOM 节点都属于相应的内建类。</li><li>层次结构（hierarchy）的根节点是 <a href="https://dom.spec.whatwg.org/#eventtarget" target="_blank" rel="noreferrer">EventTarget</a>，<a href="https://dom.spec.whatwg.org/#interface-node" target="_blank" rel="noreferrer">Node</a> 继承自它，其他 DOM 节点继承自 Node。</li><li>类： <ul><li><a href="https://dom.spec.whatwg.org/#eventtarget" target="_blank" rel="noreferrer">EventTarget</a> —— 是一切的根“抽象（abstract）”类。 该类的对象从未被创建。它作为一个基础，以便让所有 DOM 节点都支持所谓的“事件（event）”，我们会在之后学习它。</li><li><a href="http://dom.spec.whatwg.org/#interface-node" target="_blank" rel="noreferrer">Node</a> —— 也是一个“抽象”类，充当 DOM 节点的基础。 它提供了树的核心功能：<code>parentNode</code>，<code>nextSibling</code>，<code>childNodes</code> 等（它们都是 getter）。<code>Node</code> 类的对象从未被创建。但是还有一些继承自它的其他类（因此继承了 <code>Node</code> 的功能）。</li><li><a href="https://dom.spec.whatwg.org/#interface-document" target="_blank" rel="noreferrer">Document</a> 由于历史原因通常被 <code>HTMLDocument</code> 继承（尽管最新的规范没有规定）—— 是一个整体的文档。 全局变量 <code>document</code> 就是属于这个类。它作为 DOM 的入口。</li><li><a href="https://dom.spec.whatwg.org/#interface-characterdata" target="_blank" rel="noreferrer">CharacterData</a> —— 一个“抽象”类，被下述类继承： <ul><li><a href="https://dom.spec.whatwg.org/#interface-text" target="_blank" rel="noreferrer">Text</a> —— 对应于元素内部文本的类，例如 <code>&lt;p&gt;Hello&lt;/p&gt;</code> 中的 <code>Hello</code>。</li><li><a href="https://dom.spec.whatwg.org/#interface-comment" target="_blank" rel="noreferrer">Comment</a> —— 注释类。它们不会被展示出来，但每个注释都会成为 DOM 中的一员。</li></ul></li><li><a href="http://dom.spec.whatwg.org/#interface-element" target="_blank" rel="noreferrer">Element</a> —— 是 DOM 元素的基础类。 它提供了元素级导航（navigation），如 <code>nextElementSibling</code>，<code>children</code>，以及搜索方法，如 <code>getElementsByTagName</code> 和 <code>querySelector</code>。 浏览器不仅支持 HTML，还支持 XML 和 SVG。因此，<code>Element</code> 类充当的是更具体的类的基础：<code>SVGElement</code>，<code>XMLElement</code>（我们在这里不需要它）和 <code>HTMLElement</code>。</li><li>最后，<a href="https://html.spec.whatwg.org/multipage/dom.html#htmlelement" target="_blank" rel="noreferrer">HTMLElement</a> —— 是所有 HTML 元素的基础类。我们大部分时候都会用到它。 它会被更具体的 HTML 元素继承： <ul><li><a href="https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement" target="_blank" rel="noreferrer">HTMLInputElement</a> —— <code>&lt;input&gt;</code> 元素的类，</li><li><a href="https://html.spec.whatwg.org/multipage/semantics.html#htmlbodyelement" target="_blank" rel="noreferrer">HTMLBodyElement</a> —— <code>&lt;body&gt;</code> 元素的类，</li><li><a href="https://html.spec.whatwg.org/multipage/semantics.html#htmlanchorelement" target="_blank" rel="noreferrer">HTMLAnchorElement</a> —— <code>&lt;a&gt;</code> 元素的类，</li><li>……等。</li></ul></li></ul></li><li><code>console.dir(elem)</code> 与 <code>console.log(elem)</code><ol><li>它们是不同的： <ul><li><code>console.log(elem)</code> 显示元素的 DOM 树。</li><li><code>console.dir(elem)</code> 将元素显示为 DOM 对象，非常适合探索其属性。</li></ul></li></ol></li><li>规范中的 IDL <ol><li>在规范中，DOM 类不是使用 JavaScript 来描述的，而是一种特殊的 <a href="https://en.wikipedia.org/wiki/Interface_description_language" target="_blank" rel="noreferrer">接口描述语言（Interface description language）</a>，简写为 IDL，它通常很容易理解。</li></ol></li></ol></li><li><strong>“nodeType” 属性</strong><ol><li><code>nodeType</code> 属性提供了另一种“过时的”用来获取 DOM 节点类型的方法。</li><li>它有一个数值型值（numeric value）： <ul><li>对于元素节点 <code>elem.nodeType == 1</code>，</li><li>对于文本节点 <code>elem.nodeType == 3</code>，</li><li>对于 document 对象 <code>elem.nodeType == 9</code>，</li><li>在 <a href="https://dom.spec.whatwg.org/#node" target="_blank" rel="noreferrer">规范</a> 中还有一些其他值。</li></ul></li></ol></li><li><strong>标签：nodeName 和 tagName</strong><ol><li>给定一个 DOM 节点，我们可以从 <code>nodeName</code> 或者 <code>tagName</code> 属性中读取它的标签名</li><li>tagName 和 nodeName 之间有什么不同吗？ <ul><li><code>tagName</code> 属性仅适用于 <code>Element</code> 节点。</li><li><code>nodeName</code> 是为任意 <code>Node</code> 定义的：</li><li>对于元素，它的意义与 <code>tagName</code> 相同。</li><li>对于其他节点类型（text，comment 等），它拥有一个对应节点类型的字符串。</li><li><code>tagName</code> 仅受元素节点支持（因为它起源于 <code>Element</code> 类），而 <code>nodeName</code> 则可以说明其他节点类型。</li></ul></li><li>标签名称始终是大写的，除非是在 XML 模式下</li></ol></li><li><strong>innerHTML：内容</strong><ol><li><a href="https://w3c.github.io/DOM-Parsing/#the-innerhtml-mixin" target="_blank" rel="noreferrer">innerHTML</a> 属性允许将元素中的 HTML 获取为字符串形式。</li><li>如果 <code>innerHTML</code> 将一个 <code>&lt;script&gt;</code> 标签插入到 document 中 —— 它会成为 HTML 的一部分，但是不会执行。</li><li><strong>小心：“innerHTML+=” 会进行完全重写</strong><ol><li>我们可以使用 <code>elem.innerHTML+=&quot;more html&quot;</code> 将 HTML 附加到元素上。</li><li><code>innerHTML+=</code> 的作用 <ol><li>移除旧的内容。</li><li>然后写入新的 <code>innerHTML</code>（新旧结合）。</li><li><strong>因为内容已“归零”并从头开始重写，因此所有的图片和其他资源都将重写加载。</strong></li></ol></li></ol></li></ol></li><li><strong>outerHTML：元素的完整 HTML</strong><ol><li><code>outerHTML</code> 属性包含了元素的完整 HTML。就像 <code>innerHTML</code> 加上元素本身一样。</li><li><strong>与 <code>innerHTML</code> 不同，写入 <code>outerHTML</code> 不会改变元素。而是在 DOM 中替换它。</strong></li></ol></li><li><strong>nodeValue/data：文本节点内容</strong><ol><li><code>innerHTML</code> 属性仅对元素节点有效。</li><li>其他节点类型，例如文本节点，具有它们的对应项：<code>nodeValue</code> 和 <code>data</code> 属性。这两者在实际使用中几乎相同，只有细微规范上的差异。因此，我们将使用 <code>data</code>，因为它更短。</li></ol></li><li><strong>textContent：纯文本</strong><ol><li><code>textContent</code> 提供了对元素内的 <strong>文本</strong> 的访问权限：仅文本，去掉所有 <code>&lt;tags&gt;</code>。</li><li><strong>写入 <code>textContent</code> 要有用得多，因为它允许以“安全方式”写入文本。</strong></li><li><ul><li>使用 <code>textContent</code>，我们将其“作为文本”插入，所有符号（symbol）均按字面意义处理。</li></ul></li></ol></li><li><strong>“hidden” 属性</strong><ol><li>“hidden” 特性（attribute）和 DOM 属性（property）指定元素是否可见。</li><li>从技术上来说，<code>hidden</code> 与 <code>style=&quot;display:none&quot;</code> 做的是相同的事。但 <code>hidden</code> 写法更简洁。</li></ol></li><li><strong>更多属性</strong><ol><li>DOM 元素还有其他属性，特别是那些依赖于 class 的属性： <ul><li><code>value</code> —— <code>&lt;input&gt;</code>，<code>&lt;select&gt;</code> 和 <code>&lt;textarea&gt;</code>（<code>HTMLInputElement</code>，<code>HTMLSelectElement</code>……）的 value。</li><li><code>href</code> —— <code>&lt;a href=&quot;...&quot;&gt;</code>（<code>HTMLAnchorElement</code>）的 href。</li><li><code>id</code> —— 所有元素（<code>HTMLElement</code>）的 “id” 特性（attribute）的值。</li><li>……以及更多其他内容……</li></ul></li></ol></li></ol><h2 id="特性和属性-attributes-and-properties" tabindex="-1">特性和属性（Attributes and properties） <a class="header-anchor" href="#特性和属性-attributes-and-properties" aria-label="Permalink to &quot;特性和属性（Attributes and properties）&quot;">​</a></h2><p>当浏览器加载页面时，它会“读取”（或者称之为：“解析”）HTML 并从中生成 DOM 对象。对于元素节点，大多数标准的 HTML 特性（attributes）会自动变成 DOM 对象的属性（properties）。</p><ol><li><strong>DOM 属性</strong><ol><li>DOM 节点是常规的 JavaScript 对象。我们可以更改它们。</li><li>DOM 属性和方法的行为就像常规的 Javascript 对象一样 <ol><li><ul><li>它们可以有很多值。</li></ul></li><li><ul><li>它们是大小写敏感的（要写成 <code>elem.nodeType</code>，而不是 <code>elem.NoDeTyPe</code>）。</li></ul></li></ol></li></ol></li><li><strong>HTML 特性</strong><ol><li>在 HTML 中，标签可能拥有特性（attributes）。当浏览器解析 HTML 文本，并根据标签创建 DOM 对象时，浏览器会辨别 <strong>标准的</strong> 特性并以此创建 DOM 属性。</li><li>所以，当一个元素有 <code>id</code> 或其他 <strong>标准的</strong> 特性，那么就会生成对应的 DOM 属性。但是非 <strong>标准的</strong> 特性则不会。</li><li>所有特性都可以通过使用以下方法进行访问 <ul><li><code>elem.hasAttribute(name)</code> —— 检查特性是否存在。</li><li><code>elem.getAttribute(name)</code> —— 获取这个特性值。</li><li><code>elem.setAttribute(name, value)</code> —— 设置这个特性值。</li><li><code>elem.removeAttribute(name)</code> —— 移除这个特性。</li></ul></li><li>HTML 特性有以下几个特征 <ul><li>它们的名字是大小写不敏感的（<code>id</code> 与 <code>ID</code> 相同）。</li><li>它们的值总是字符串类型的。</li></ul></li></ol></li><li><strong>属性—特性同步</strong><ol><li>当一个标准的特性被改变，对应的属性也会自动更新，（除了几个特例）反之亦然。</li></ol></li><li><strong>DOM 属性是多类型的</strong><ol><li>DOM 属性不总是字符串类型的。</li></ol></li><li><strong>非标准的特性，dataset</strong><ol><li>有时，非标准的特性常常用于将自定义的数据从 HTML 传递到 JavaScript，或者用于为 JavaScript “标记” HTML 元素。</li><li><strong>所有以 “data-” 开头的特性均被保留供程序员使用。它们可在 <code>dataset</code> 属性中使用。</strong></li></ol></li></ol><h2 id="修改文档-document" tabindex="-1">修改文档（document） <a class="header-anchor" href="#修改文档-document" aria-label="Permalink to &quot;修改文档（document）&quot;">​</a></h2><p>DOM 修改是创建“实时”页面的关键。</p><p><strong>例子：展示一条消息</strong></p><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.alert {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  padding: 15px;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  border: 1px solid #d6e9c6;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  border</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">radius: 4px;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  color: #3c763d;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  background</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">color: #dff0d8;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;alert&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">strong</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hi there!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">strong</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; You&#39;ve read an important message.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>创建一个元素</strong></p><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//用给定的文本创建一个 文本节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> textNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createTextNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Here I am&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>创建一条消息</strong></p><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. 创建 &lt;div&gt; 元素</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. 将元素的类设置为 &quot;alert&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.className </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;alert&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3. 填充消息内容</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.innerHTML </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&lt;strong&gt;Hi there!&lt;/strong&gt; You&#39;ve read an important message.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol><li><strong>插入方法</strong><ol><li>元素插入方法，指明了不同的插入位置 <ul><li><code>node.append(...nodes or strings)</code> —— 在 <code>node</code> <strong>末尾</strong> 插入节点或字符串，</li><li><code>node.prepend(...nodes or strings)</code> —— 在 <code>node</code> <strong>开头</strong> 插入节点或字符串，</li><li><code>node.before(...nodes or strings)</code> —— 在 <code>node</code> <strong>前面</strong> 插入节点或字符串，</li><li><code>node.after(...nodes or strings)</code> —— 在 <code>node</code> <strong>后面</strong> 插入节点或字符串，</li><li><code>node.replaceWith(...nodes or strings)</code> —— 将 <code>node</code> 替换为给定的节点或字符串。</li></ul></li></ol></li><li><strong>insertAdjacentHTML/Text/Element</strong><ol><li>一个非常通用的方法：<code>elem.insertAdjacentHTML(where, html)</code>。 <ul><li><code>&quot;beforebegin&quot;</code> —— 将 <code>html</code> 插入到 <code>elem</code> 之前，</li><li><code>&quot;afterbegin&quot;</code> —— 将 <code>html</code> 插入到 <code>elem</code> 开头，</li><li><code>&quot;beforeend&quot;</code> —— 将 <code>html</code> 插入到 <code>elem</code> 末尾，</li><li><code>&quot;afterend&quot;</code> —— 将 <code>html</code> 插入到 <code>elem</code> 之后。</li></ul></li><li>这个方法有两个兄弟 <ol><li><ul><li><code>elem.insertAdjacentText(where, text)</code> —— 语法一样，但是将 <code>text</code> 字符串“作为文本”插入而不是作为 HTML，</li></ul></li><li><ul><li><code>elem.insertAdjacentElement(where, elem)</code> —— 语法一样，但是插入的是一个元素。</li></ul></li></ol></li></ol></li><li><strong>节点移除</strong><ol><li>想要移除一个节点，可以使用 <code>node.remove()</code>。</li><li>如果我们要将一个元素 <strong>移动</strong> 到另一个地方，则无需将其从原来的位置中删除。</li><li><strong>所有插入方法都会自动从旧位置删除该节点。</strong></li></ol></li><li><strong>克隆节点：cloneNode</strong><ol><li>调用 <code>elem.cloneNode(true)</code> 来创建元素的一个“深”克隆 —— 具有所有特性（attribute）和子元素。如果我们调用 <code>elem.cloneNode(false)</code>，那克隆就不包括子元素。</li></ol></li><li><strong>DocumentFragment</strong><ol><li><code>DocumentFragment</code> 是一个特殊的 DOM 节点，用作来传递节点列表的包装器（wrapper）。</li></ol></li><li>老式的 insert/remove 方法</li><li><strong>聊一聊 “document.write”</strong><ol><li>还有一个非常古老的向网页添加内容的方法：<code>document.write</code>。</li><li>调用 <code>document.write(html)</code> 意味着将 <code>html</code> “就地马上”写入页面。<code>html</code> 字符串可以是动态生成的，所以它很灵活。我们可以使用 JavaScript 创建一个完整的页面并对其进行写入。</li><li><strong><code>document.write</code> 调用只在页面加载时工作。</strong></li><li>运行起来出奇的快，因为它 <strong>不涉及 DOM 修改</strong>。</li></ol></li></ol><h2 id="样式和类" tabindex="-1">样式和类 <a class="header-anchor" href="#样式和类" aria-label="Permalink to &quot;样式和类&quot;">​</a></h2><p>通常有两种设置元素样式的方式： 1. 在 CSS 中创建一个类，并添加它：<code>&lt;div class=&quot;...&quot;&gt;</code> 2. 将属性直接写入 <code>style</code>：<code>&lt;div style=&quot;...&quot;&gt;</code>。</p><ol><li><strong>className 和 classList</strong><ol><li>更改类是脚本中最常见的操作之一。</li><li><code>&quot;className&quot;</code>：<code>elem.className</code> 对应于 <code>&quot;class&quot;</code> 特性（attribute）。</li><li><code>elem.classList</code> 是一个特殊的对象，它具有 <code>add/remove/toggle</code> 单个类的方法。</li><li><code>classList</code> 的方法 <ul><li><code>elem.classList.add/remove(class)</code> —— 添加/移除类。</li><li><code>elem.classList.toggle(class)</code> —— 如果类不存在就添加类，存在就移除它。</li><li><code>elem.classList.contains(class)</code> —— 检查给定类，返回 <code>true/false</code>。</li></ul></li></ol></li><li><strong>元素样式</strong><ol><li><code>elem.style</code> 属性是一个对象，它对应于 <code>&quot;style&quot;</code> 特性（attribute）中所写的内容。<code>elem.style.width=&quot;100px&quot;</code> 的效果等价于我们在 <code>style</code> 特性中有一个 <code>width:100px</code> 字符串。</li></ol></li><li><strong>重置样式属性</strong><ol><li>有时我们想要分配一个样式属性，稍后移除它。</li><li>这里不应该使用 <code>delete elem.style.display</code>，而应该使用 <code>elem.style.display = &quot;&quot;</code> 将其赋值为空。</li><li>用 <code>style.cssText</code> 进行完全的重写 <ol><li>我们使用 <code>style.*</code> 来对各个样式属性进行赋值。我们不能像这样的 <code>div.style=&quot;color: red; width: 100px&quot;</code> 设置完整的属性，因为 <code>div.style</code> 是一个对象，并且它是只读的。</li></ol></li></ol></li><li><strong>注意单位</strong><ol><li>px，rem，vh等</li></ol></li><li><strong>计算样式：getComputedStyle</strong><ol><li><strong><code>style</code> 属性仅对 <code>&quot;style&quot;</code> 特性（attribute）值起作用，而没有任何 CSS 级联（cascade）。</strong></li><li><strong>element</strong><ol><li>需要被读取样式值的元素。</li></ol></li><li><strong>pseudo</strong><ol><li>伪元素（如果需要），例如 <code>::before</code>。空字符串或无参数则意味着元素本身。</li></ol></li><li>计算值和解析值 <ol><li><strong>计算 (computed)</strong> 样式值是所有 CSS 规则和 CSS 继承都应用后的值，这是 CSS 级联（cascade）的结果。它看起来像 <code>height:1em</code> 或 <code>font-size:125%</code>。</li><li><strong>解析 (resolved)</strong> 样式值是最终应用于元素的样式值。诸如 <code>1em</code> 或 <code>125%</code> 这样的值是相对的。浏览器将使用计算（computed）值，并使所有单位均为固定的，且为绝对单位，例如：<code>height:20px</code> 或 <code>font-size:16px</code>。对于几何属性，解析（resolved）值可能具有浮点，例如：<code>width:50.5px</code>。</li></ol></li><li><code>getComputedStyle</code> 需要完整的属性名 <ol><li>要的确切的属性，例如 <code>paddingLeft</code>、<code>marginTop</code> 或 <code>borderTopWidth</code>。否则，就不能保证正确的结果。</li></ol></li><li>应用于 <code>:visited</code> 链接的样式被隐藏了！ <ol><li>可以使用 CSS 伪类 <code>:visited</code> 对被访问过的链接进行着色。</li><li>但 <code>getComputedStyle</code> 没有给出访问该颜色的方式，因为如果允许的话，任意页面都可以通过在页面上创建它，并通过检查样式来确定用户是否访问了某链接。</li><li>JavaScript 看不到 <code>:visited</code> 所应用的样式。</li></ol></li></ol></li></ol><h2 id="元素大小和滚动" tabindex="-1">元素大小和滚动 <a class="header-anchor" href="#元素大小和滚动" aria-label="Permalink to &quot;元素大小和滚动&quot;">​</a></h2><ol><li><strong>offsetParent，offsetLeft/Top</strong><ol><li><code>offsetParent</code> 是最接近的祖先（ancestor），在浏览器渲染期间，它被用于计算坐标。</li><li>最近的祖先为下列之一： <ol><li><ol><li>CSS 定位的（<code>position</code> 为 <code>absolute</code>、<code>relative</code>、<code>fixed</code> 或 <code>sticky</code>），</li></ol></li><li>或 <code>&lt;td&gt;</code>，<code>&lt;th&gt;</code>，<code>&lt;table&gt;</code>，</li><li>或 <code>&lt;body&gt;</code>。</li><li>属性 <code>offsetLeft/offsetTop</code> 提供相对于 <code>offsetParent</code> 左上角的 x/y 坐标。</li><li>有以下几种情况下，<code>offsetParent</code> 的值为 <code>null</code>： <ol><li>对于未显示的元素（<code>display:none</code> 或者不在文档中）。</li><li>对于 <code>&lt;body&gt;</code> 与 <code>&lt;html&gt;</code>。</li><li>对于带有 <code>position:fixed</code> 的元素。</li></ol></li></ol></li></ol></li><li><strong>offsetWidth/Height</strong><ol><li>提供了元素的“外部” width/height <ol><li><ul><li><code>offsetWidth = 390</code> —— 外部宽度（width），可以计算为内部 CSS-width（<code>300px</code>）加上 padding（<code>2 * 20px</code>）和 border（<code>2 * 25px</code>）。</li></ul></li><li><ul><li><code>offsetHeight = 290</code> —— 外部高度（height）。</li></ul></li></ol></li><li><strong>对于未显示的元素，几何属性为 0/null</strong><ol><li>如果一个元素（或其任何祖先）具有 <code>display:none</code> 或不在文档中，则所有几何属性均为零（或 <code>offsetParent</code> 为 <code>null</code>）。</li><li>当我们创建了一个元素，但尚未将其插入文档中，或者它（或它的祖先）具有 <code>display:none</code> 时，<code>offsetParent</code> 为 <code>null</code>，并且 <code>offsetWidth</code> 和 <code>offsetHeight</code> 为 <code>0</code>。</li></ol></li></ol></li><li><strong>clientTop/Left</strong><ol><li>为了测量它们，可以使用 <code>clientTop</code> 和 <code>clientLeft</code>。 <ol><li><ul><li><code>clientLeft = 25</code> —— 左边框宽度</li></ul></li><li><ul><li><code>clientTop = 25</code> —— 上边框宽度</li></ul></li></ol></li></ol></li><li><strong>clientWidth/Height</strong><ol><li>“content width” 和 “padding”，但不包括滚动条宽度（scrollbar）</li></ol></li><li><strong>scrollWidth/Height</strong><ol><li>属性就像 <code>clientWidth/clientHeight</code>，但它们还包括滚动出（隐藏）的部分</li><li>是内容区域的完整内部高度，包括滚动出的部分。</li><li>是完整的内部宽度，这里我们没有水平滚动，因此它等于 <code>clientWidth</code>。</li></ol></li><li>s<strong>crollLeft/scrollTop</strong><ol><li>属性 <code>scrollLeft/scrollTop</code> 是元素的隐藏、滚动部分的 width/height。</li><li>scrollLeft/scrollTop 是可修改的</li><li>大多数几何属性是只读的，但是 <code>scrollLeft/scrollTop</code> 是可修改的，并且浏览器会滚动该元素。</li></ol></li><li><strong>不要从 CSS 中获取 width/height</strong><ol><li><ol><li>首先，CSS <code>width/height</code> 取决于另一个属性：<code>box-sizing</code>，它定义了“什么是” CSS 宽度和高度。出于 CSS 的目的而对 <code>box-sizing</code> 进行的更改可能会破坏此类 JavaScript 操作。</li></ol></li><li>其次，CSS 的 <code>width/height</code> 可能是 <code>auto</code>，例如内联（inline）元素</li></ol></li></ol><h2 id="window-大小和滚动" tabindex="-1">Window 大小和滚动 <a class="header-anchor" href="#window-大小和滚动" aria-label="Permalink to &quot;Window 大小和滚动&quot;">​</a></h2><ol><li><strong>窗口的 width/height</strong><ol><li>为了获取窗口（window）的宽度和高度，我们可以使用 <code>document.documentElement</code> 的 <code>clientWidth/clientHeight</code></li><li>不是 <code>window.innerWidth/innerHeight</code><ol><li>如果这里存在一个滚动条，并且滚动条占用了一些空间，那么 <code>clientWidth/clientHeight</code> 会提供没有滚动条（减去它）的 width/height。换句话说，它们返回的是可用于内容的文档的可见部分的 width/height。<code>window.innerWidth/innerHeight</code> 包括了滚动条。</li></ol></li><li><code>DOCTYPE</code> 很重要 <ol><li>当 HTML 中没有 <code>&lt;!DOCTYPE HTML&gt;</code> 时，顶层级（top-level）几何属性的工作方式可能就会有所不同。可能会出现一些稀奇古怪的情况。</li></ol></li></ol></li><li><strong>文档的 width/height</strong><ol><li>由于根文档元素是 <code>document.documentElement</code>，并且它包围了所有内容，因此我们可以通过使用 <code>documentElement.scrollWidth/scrollHeight</code> 来测量文档的完整大小。</li></ol></li><li><strong>获得当前滚动</strong><ol><li>DOM 元素的当前滚动状态在其 <code>scrollLeft/scrollTop</code> 属性中。</li><li>对于文档滚动，在大多数浏览器中，我们可以使用 <code>document.documentElement.scrollLeft/scrollTop</code>，但在较旧的基于 WebKit 的浏览器中则不行，例如在 Safari（bug <a href="https://bugs.webkit.org/show_bug.cgi?id=5991" target="_blank" rel="noreferrer">5991</a>）中，我们应该使用 <code>document.body</code> 而不是 <code>document.documentElement</code>。</li></ol></li><li>我们也可以从 <code>window</code> 的 <code>scrollX</code> 和 <code>scrollY</code> 属性中获取滚动信息 <ol><li><ul><li><code>window.pageXOffset</code> 是 <code>window.scrollX</code> 的别名。</li></ul></li><li><ul><li><code>window.pageYOffset</code> 是 <code>window.scrollY</code> 的别名。</li></ul></li></ol></li><li><strong>滚动：scrollTo，scrollBy，scrollIntoView</strong><ol><li>可以通过更改 <code>scrollTop/scrollLeft</code> 来滚动常规元素 <ol><li>方法 <code>scrollBy(x,y)</code> 将页面滚动至 <strong>相对于当前位置的 <code>(x, y)</code> 位置</strong>。例如，<code>scrollBy(0,10)</code> 会将页面向下滚动 <code>10px</code>。</li><li>方法 <code>scrollTo(pageX,pageY)</code> 将页面滚动至 <strong>绝对坐标</strong>，使得可见部分的左上角具有相对于文档左上角的坐标 <code>(pageX, pageY)</code>。就像设置了 <code>scrollLeft/scrollTop</code> 一样。</li></ol></li></ol></li><li><strong>scrollIntoView</strong><ol><li><code>elem.scrollIntoView(top)</code> 的调用将滚动页面以使 <code>elem</code> 可见。它有一个参数 <ol><li><ul><li>如果 <code>top=true</code>（默认值），页面滚动，使 <code>elem</code> 出现在窗口顶部。元素的上边缘将与窗口顶部对齐。</li></ul></li><li><ul><li>如果 <code>top=false</code>，页面滚动，使 <code>elem</code> 出现在窗口底部。元素的底部边缘将与窗口底部对齐。</li></ul></li></ol></li></ol></li><li><strong>禁止滚动</strong><ol><li>要使文档不可滚动，只需要设置 <code>document.body.style.overflow = &quot;hidden&quot;</code>。</li></ol></li></ol><h2 id="坐标" tabindex="-1">坐标 <a class="header-anchor" href="#坐标" aria-label="Permalink to &quot;坐标&quot;">​</a></h2><p>移动页面的元素，我们应该先熟悉坐标</p><ol><li>大多数 JavaScript 方法处理的是以下两种坐标系中的一个 <ol><li><strong>相对于窗口</strong> —— 类似于 <code>position:fixed</code>，从窗口的顶部/左侧边缘计算得出。 <ul><li>我们将这些坐标表示为 <code>clientX/clientY</code>，当我们研究事件属性时，就会明白为什么使用这种名称来表示坐标。</li></ul></li><li><strong>相对于文档</strong> —— 与文档根（document root）中的 <code>position:absolute</code> 类似，从文档的顶部/左侧边缘计算得出。 <ul><li>我们将它们表示为 <code>pageX/pageY</code>。</li></ul></li></ol></li><li><strong>元素坐标：getBoundingClientRect</strong><ol><li>方法 <code>elem.getBoundingClientRect()</code> 返回最小矩形的窗口坐标，该矩形将 <code>elem</code> 作为内建 <a href="https://www.w3.org/TR/geometry-1/#domrect" target="_blank" rel="noreferrer">DOMRect</a> 类的对象。</li><li>主要的 <code>DOMRect</code> 属性 <ol><li><ul><li><code>x/y</code> —— 矩形原点相对于窗口的 X/Y 坐标，</li></ul></li><li><ul><li><code>width/height</code> —— 矩形的 width/height（可以为负）。</li></ul></li></ol></li><li>派生（derived）属性 <ol><li><ul><li><code>top/bottom</code> —— 顶部/底部矩形边缘的 Y 坐标，</li></ul></li><li><ul><li><code>left/right</code> —— 左/右矩形边缘的 X 坐标。</li></ul></li></ol></li><li>为什么需要派生（derived）属性？如果有了 <code>x/y</code>，为什么还要还会存在 <code>top/left</code>？ <ol><li>从技术上讲，<code>width/height</code> 可能为负数，从而允许“定向（directed）”矩形，例如代表带有正确标记的开始和结束的鼠标选择。</li><li>负的 <code>width/height</code> 值表示矩形从其右下角开始，然后向左上方“增长”。</li><li><code>elem.getBoundingClientRect()</code> 总是返回正数的 width/height，这里我们提及负的 <code>width/height</code> 只是为了帮助你理解，为什么这些看起来重复的属性，实际上并不是重复的。</li></ol></li><li>IE 浏览器不支持 <code>x/y</code><ol><li>由于历史原因，IE 浏览器不支持 <code>x/y</code> 属性。</li></ol></li><li>坐标的 right/bottom 与 CSS position 属性不同 <ol><li>相对于窗口（window）的坐标和 CSS <code>position:fixed</code> 之间有明显的相似之处。</li><li>在 CSS 定位中，<code>right</code> 属性表示距右边缘的距离，而 <code>bottom</code> 属性表示距下边缘的距离</li></ol></li><li>elementFromPoint(x, y) <ol><li>对 <code>document.elementFromPoint(x, y)</code> 的调用会返回在窗口坐标 <code>(x, y)</code> 处嵌套最多（the most nested）的元素。</li></ol></li><li>对于在窗口之外的坐标，<code>elementFromPoint</code> 返回 <code>null</code><ol><li>方法 <code>document.elementFromPoint(x,y)</code> 只对在可见区域内的坐标 <code>(x,y)</code> 起作用。</li><li>如果任何坐标为负或者超过了窗口的 width/height，那么该方法就会返回 <code>null</code>。</li></ol></li><li>用于 “fixed” 定位 <ol><li>想要在某元素附近展示内容，我们可以使用 <code>getBoundingClientRect</code> 来获取这个元素的坐标，然后使用 CSS <code>position</code> 以及 <code>left/top</code>（或 <code>right/bottom</code>）。</li></ol></li><li><strong>文档坐标</strong><ol><li>在 CSS 中，窗口坐标对应于 <code>position:fixed</code>，而文档坐标与顶部的 <code>position:absolute</code> 类似。</li><li>我们可以使用 <code>position:absolute</code> 和 <code>top/left</code> 来把某些内容放到文档中的某个位置，以便在页面滚动时，元素仍能保留在该位置。但是我们首先需要正确的坐标。</li><li><ul><li><code>pageY</code> = <code>clientY</code> + 文档的垂直滚动出的部分的高度。</li></ul></li><li><code>pageX</code> = <code>clientX</code> + 文档的水平滚动出的部分的宽度。</li></ol></li></ol></li></ol>`,35)]))}const u=l(d,[["render",s]]);export{p as __pageData,u as default};
